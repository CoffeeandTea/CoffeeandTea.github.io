<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="秋夜已凉 02">
<meta property="og:url" content="https://coffeeandtea.github.io/index.html">
<meta property="og:site_name" content="秋夜已凉 02">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秋夜已凉 02">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://coffeeandtea.github.io/">





  <title>秋夜已凉 02</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">秋夜已凉 02</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">博客年久失修还是来点音乐吧～～ 去 <a href="http://music.xiaoyu.work" target="_blank">http://music.xiaoyu.work</a> 都是你爱听的🎵～</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/07/30/使用css变量的好处/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/30/使用css变量的好处/" itemprop="url">css变量稿一键换肤</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-30T15:22:43+08:00">
                2020-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;].forEach(v =&gt; {
const btn = document.getElementById(`${v}-theme-btn`);
    btn.addEventListener(&quot;click&quot;, () =&gt; document.body.style.setProperty(&quot;--bg-color&quot;, v));
});</code></pre><h4 id="使用css变量的好处"><a href="#使用css变量的好处" class="headerlink" title="使用css变量的好处"></a>使用css变量的好处</h4><ul>
<li>减少样式代码的重复性</li>
<li>增加样式代码的扩展性</li>
<li>提高样式代码的灵活性</li>
<li>增多一种css与js的通讯方式</li>
<li>不用深层次遍历dom改变某个样式</li>
</ul>
<p>未完待续…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/07/30/关于缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/30/关于缓存/" itemprop="url">缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-30T14:21:33+08:00">
                2020-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>浏览器每次发起请求之前都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果缓存和缓存表识存入浏览器缓存中</li>
</ul>
<h3 id="强制缓存规则的三种场景"><a href="#强制缓存规则的三种场景" class="headerlink" title="强制缓存规则的三种场景"></a>强制缓存规则的三种场景</h3><ul>
<li>没有找到请求的缓存结果以及缓存标识（直接发起http请求）</li>
<li>找到了请求的缓存结果以及缓存标识，但是显示已经失效（携带资源的缓存标识发起http请求—-协商缓存的过程）</li>
<li>找到了请求的缓存结果和缓存标识，并且未失效，直接使用缓存中的结果</li>
</ul>
<h3 id="强制缓存的规则字段"><a href="#强制缓存的规则字段" class="headerlink" title="强制缓存的规则字段"></a>强制缓存的规则字段</h3><p>按优先级 </p>
<pre><code>Cache-Control &gt; Expires</code></pre><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires是HTTP/1.0中控制网页缓存的字段，值为服务器返回的请求结果缓存的到期时间，即再次发起请求时，客户端的时间如果小于Expires的值，就可以直接使用缓存。</p>
<h5 id="缺点：客户端的时间是可以“灵活”改变的，你懂的～（不同时区，或者人为修改系统时间…）"><a href="#缺点：客户端的时间是可以“灵活”改变的，你懂的～（不同时区，或者人为修改系统时间…）" class="headerlink" title="缺点：客户端的时间是可以“灵活”改变的，你懂的～（不同时区，或者人为修改系统时间…）"></a>缺点：客户端的时间是可以“灵活”改变的，你懂的～（不同时区，或者人为修改系统时间…）</h5><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>到了http/1.1，为了修复Expires的不可靠性，引入了Cache-Control的规则，他的值主要有：</p>
<ul>
<li>public: 允许中间代理服务器和客户端缓存</li>
<li>private: 只允许客户端缓存不允许中间代理服务缓存（默认值）</li>
<li>no-store: 所有内容不允许缓存（强制缓存和协商缓存都不用）</li>
<li>no-catch: 客户端缓存内容，但是是否使用缓存需要经过协商缓存来验证</li>
<li>max-age=xxx: 缓存会在xxx秒之后失效</li>
</ul>
<h3 id="memory-cache和disk-cache"><a href="#memory-cache和disk-cache" class="headerlink" title="memory cache和disk cache"></a>memory cache和disk cache</h3><p>刷新页面的时候我们会看到有些资源是from memory cache 有些则是from disk cache,这两个分别代表的是内存缓存和硬盘缓存。</p>
<h5 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h5><ul>
<li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取</li>
<li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li>
</ul>
<h5 id="disk-cache"><a href="#disk-cache" class="headerlink" title="disk cache"></a>disk cache</h5><ul>
<li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢</li>
</ul>
<p>在浏览器中浏览器会在js和图片等文件解析执行后直接存入内存缓存中，而css文件则会存入硬盘文件中，所以每次刷新页面有些是从内存缓存中读取，而有些则是从硬盘中读取。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否可以使用缓存的过程。主要有两种情况</p>
<ul>
<li>协商缓存生效，返回304</li>
<li>协商缓存失效，返回一个新的请求结果以及200状态码</li>
</ul>
<h4 id="控制协商缓存的头字段"><a href="#控制协商缓存的头字段" class="headerlink" title="控制协商缓存的头字段"></a>控制协商缓存的头字段</h4><p><strong><em>Last-Modified/If-Modified-Since 和 Etag/If-None-Match</em></strong></p>
<ul>
<li>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件.</li>
<li>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200.</li>
</ul>
<p>Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/07/30/js函数式编程？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/30/js函数式编程？/" itemprop="url">javascript函数式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-30T09:51:23+08:00">
                2020-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h3><h5 id="数学中的函数"><a href="#数学中的函数" class="headerlink" title="数学中的函数"></a>数学中的函数</h5><pre><code>f(x) = y</code></pre><ul>
<li>函数必须总是接受一个参数</li>
<li>函数必须总是返回一个值</li>
<li>函数应该依据接收到的参数而不是外部环境运行</li>
<li>对于一个给定的x,只会输出唯一的一个y</li>
</ul>
<pre><code>var percentValue = 5;
var calculateTex = (value) =&gt; {
    return value/100 * (100 + percentValue )）
}</code></pre><p>上面的计税函数不是一个纯函数在于它依赖了全局变量percentValue ，修复方法很简单，只需要移动全局变量percentValue ，把它作为函数的参数改写如下：</p>
<pre><code>var calculateTex = (value, percentValue ) =&gt; {
return value/100 * (100 + percentValue )
}</code></pre><p>现在calculateTex 可以被称为一个真正的纯函数了。<br>将函数对全局变量的依赖移到函数的参数中是最常见的一种“纯函数化”的方式，移除函数对全局变量的访问会使得函数的测试更加容易。</p>
<h3 id="引用透明性-（Referential-Transparency）"><a href="#引用透明性-（Referential-Transparency）" class="headerlink" title="引用透明性 （Referential Transparency）"></a>引用透明性 （Referential Transparency）</h3><p>函数对于相同的输入都将返回相同的值，这一属性被称为引用透明性。依据函数的这一属性可以直接用函数的结果替换掉函数的调用，这个过程被称为替换模型，这些特性使得并发代码和缓存称为可能。多线程和同步的问题在于对全局数据的依赖上，而遵循引用透明性的函数只依赖参数的输入而不依赖全局数据，所以线程可以自由的运行且没有锁的机制。<br>引用透明性是一种<a href="https://en.wikipedia.org/wiki/Analytical_philosophy" target="_blank" rel="noopener">分析哲学</a></p>
<h3 id="函数式编程与命令式编程的对比"><a href="#函数式编程与命令式编程的对比" class="headerlink" title="函数式编程与命令式编程的对比"></a>函数式编程与命令式编程的对比</h3><h5 id="命令式编程遍历数组"><a href="#命令式编程遍历数组" class="headerlink" title="命令式编程遍历数组"></a>命令式编程遍历数组</h5><pre><code>let array = [1,2,3]
for (let i = 0; i&lt; array.length; i++) {
console.log(array[i])
}</code></pre><h5 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h5><pre><code>let array = [1,2,3]
array.forEach(item =&gt; console.log(item))</code></pre><p>在函数式编程中我们移除了“如何做”的部分将他抽象到一个函数中（高阶函数），如此可以让开发者只需要关心手头的问题</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><ul>
<li>纯函数不应该依赖任何外部变量，同时也不应该改变任何外部变量。</li>
<li>纯函数应该像Math.max(3,4,5,6)一样，不需要看max的内部实现就能得到结果。</li>
<li>纯函数允许我们并发的执行代码，因为纯函数不会改变它的环境，意味着我们不需要关心同步的问题。</li>
<li>纯函数使缓存函数的输出避免下次重新计算成为可能</li>
<li>纯函数应该被设计成只做一件事（单一职责）就像UNIX哲学那样，我们可以通过组合或者管道来完成复杂的任务</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/07/03/Array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/03/Array/" itemprop="url">数组Array</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-03T00:46:43+08:00">
                2020-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><p><strong><em>想要吗？想要你说啊，你不说我怎么知道你想要</em></strong></p>
<hr>
<p>“<strong>为了按照某个方式进行排序，必须给sort方法传递一个比较函数，该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于0的数值，假如第一个参数应该在后，函数应该返回一个大于0的数值，如果两个数值相等，那么他们的顺序无关紧要，此时函数应该返回0。</strong>”</p>
<p>这是js权威指南中对数组sort方法的描述，红包书中的描述与此类似，并给出了函数的例子：</p>
<pre><code>function compare(value1, value2) {
    if (value 1 &lt; value2) {
        return -1;
    } else if (value1 &gt; value2) {
        return 1;
    } else {
        return 0;
    }
}</code></pre><p>只要将compare函数作为参数传递给sort方法即可，如下所示：</p>
<pre><code>var values = [0,1,5,10,15];

values.sort(compare); // 0,1,5,10,15</code></pre><p>这里的解释是：如果第一个参数应该位于第二个参数之前，则返回一个负数，如果第一个参数应该位于第二个参数之后则返回一个正数。</p>
<p>所以其实这个函数的规则定义是一个<strong>从结果来推导条件</strong>的过程，函数的逻辑已经定义好了：无论你要比较什么，我的规则比较后的结果就是：<strong><em>如果第一个参数应该位于第二个参数之前，则返回一个负数，如果第一个参数应该位于第二个参数之后则返回一个正数</em></strong>，这里的a,b的理解就是<strong>待排序数组中的任意两个元素</strong>，没有什么顺序的规定，也不是什么一定相邻的两个元素，就是<strong>任意</strong>两个元素。我们使用sort来进行排序的时候实际是根据它比较结果的规则来去写我们的比较条件的，也就是if表达式，告诉它什么时候返回-1，什么时候返回1，也就是告诉它深呢时候把a排前面，什么时候把a排后面。这个规则要写完整，不能只写一半只告诉它什么情况下把a排在前面，其他情况不写，它就不知怎么排了。</p>
<p>简单记忆： a - b 是生序 b - a 是降序，其实是一中“偷懒”的记忆方式，可以用来快速的进行排序，但是也要记得sort函数最原始的规则：如果第一个参数应该位于第二个参数之前，则返回一个负数，如果第一个参数应该位于第二个参数之后则返回一个正数。</p>
<p>如果忘记了sort方法，可以去看自己在力扣上做的第1122题</p>
<pre><code>https://leetcode-cn.com/problems/relative-sort-array/solution/sortfang-fa-zui-jing-jian-fang-shi-by-storm-24/</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/07/01/DNS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/01/DNS/" itemprop="url">DNS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-01T15:04:39+08:00">
                2020-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="浏览器发起请求的几个重要步骤"><a href="#浏览器发起请求的几个重要步骤" class="headerlink" title="浏览器发起请求的几个重要步骤"></a>浏览器发起请求的几个重要步骤</h3><ul>
<li>DNS解析</li>
<li>TCP链接</li>
<li>发送http请求</li>
<li>服务器处理请求并返回http报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ul>
<p>DNS缓存，减少浏览器访问dns服务器的时间</p>
<p>部署CDN：CDN的域名不要和主站的域名一样，这样就会防止访问CDN时还携带着主站cookies的问题。</p>
<p>浏览器端缓存</p>
<p>服务端渲染ssr</p>
<p>HTTP是不保存状态的协议，即无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。这也是Cookie技术产生的重要原因之一：客户端的状态管理。浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保持 Cookie。而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务端识别客户端身份状态的标识。</p>
<h3 id="TCP-IP四层网络模型"><a href="#TCP-IP四层网络模型" class="headerlink" title="TCP/IP四层网络模型"></a>TCP/IP四层网络模型</h3><p>应用层<br>传输层<br>网际层<br>链路层</p>
<p>持久连接采用队头阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没有返回响应内容，下次请求就必须只能等着，就是常说的队头阻塞。（解决方案，管道化）</p>
<p>需要注意，如果使用反向代理，则在axios配置的时候，请求baseURL必须设置为字符串‘/’，否则proxy会匹配不到’/api’导致代理失败。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/07/01/http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/01/http/" itemprop="url">http</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-01T15:03:21+08:00">
                2020-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>http所谓的“超文本传输协议”其实并不怎么管“传输”的事情。</p>
<p>http协议的核心部分是它传输的报文内容。</p>
<p>http是一个纯文本的协议，所以头数据都是ASCII码的文本，可以很容易地用肉眼</p>
<p>阅读，不用借助程序解析也能看懂。</p>
<p>起始行(start line) + 头部字段(header) = <strong><em>请求头</em></strong></p>
<p>消息正文又称为<strong><em>实体</em></strong>但是与header对应，很多时候就直接称为<strong><em>body</em></strong></p>
<p>http协议规定报文必须有header并且header之后必须要有一个空行，但是可以没有body</p>
<p>在很多时候，特别是浏览器发送get请求的时候都是这样，http报文经常是只有header而没有body,相当于只发了一个超级“大头”过来，可以想象为：每时每刻网络上都有数不清的“大头儿子”在跑来跑去。不过这个大头也不能太大，虽然http协议对header的大小没有做限制，但是各个web服务器都不会允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。</p>
<p>请求行简要描述了客户端想要如何操作服务器端的资源。</p>
<p>由三部分构成：</p>
<ul>
<li>请求方法</li>
<li>请求目标</li>
<li>版本号</li>
</ul>
<p>这三个部分通常使用空格来分隔。</p>
<p>例如：GET / HTTP/1.1</p>
<ul>
<li>GET是请求方法</li>
<li>/是请求目标</li>
<li>HTTP/1.1是版本号</li>
</ul>
<p>意思就是： “服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是1.1请不要用1.0或者2.0回复我。</p>
<p>请求行或状态行再加上头部字段集合就构成了http报文里完整的请求头或响应头。</p>
<p>http头字段非常灵活，不仅可以使用标准里的host、connection等已经定义的头，也可以任意添加自定义头，这就给http协议带来了无限的扩展可能。</p>
<p>注意：</p>
<ul>
<li>字段名不区分大小写，但是首字母大写的可读性更好</li>
<li>字段里不允许出现空格、下划线_,但是可以使用连字符</li>
</ul>
<p>常用头字段</p>
<ul>
<li>通用字段</li>
<li>请求字段</li>
<li>响应字段</li>
<li>实体字段： 实际上可以归为通用字段，但是专门用来描述body的额外信息</li>
</ul>
<p>对http报文的解析和处理实际上就是对头字段的处理，理解了头字段也就理解了http报文</p>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>属于请求字段，只能出现在请求头里，同时也是唯一一个http1.1规范里要求必须出现的字段，如果请求头部字段里没有这个host，那这就是一个错误的报文。host字段用来告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用host字段来选择，有点像一个简单的“路由重定向”。</p>
<p>1:如果拼 HTTP 报文的时候，在头字段后多加了一个 CRLF，导致出现了一个空行，会发生什么？<br>在header 下面第一个空行以后都会被当作body 体</p>
<p>2:讲头字段时说“:”后的空格可以有多个，那为什么绝大多数情况下都只使用一个空格呢？<br>头部多一个空格就会多一个传输的字节，去掉无用的信息，保证传输的头部字节数尽量小</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/06/20/px2rem或postcss-px2rem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/20/px2rem或postcss-px2rem/" itemprop="url">移动端适配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-20T19:34:01+08:00">
                2020-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="px2rem或postcss-px2rem"><a href="#px2rem或postcss-px2rem" class="headerlink" title="px2rem或postcss-px2rem"></a>px2rem或postcss-px2rem</h3><ul>
<li>在移动端中，为了适配不同的设备，通常用rem来做适配</li>
<li>rem是通过根元素进行适配的，网页中的根元素指的是<html>，我们通过设置</html></li>
</ul>
<p>假值列表：</p>
<p>以下这些是假值</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0、-0、NaN</li>
<li>“”</li>
</ul>
<p>除了以上这些假值以外的值都是真值，也就是说没有一个真值列表，真值的列表可以无限长，无法一一列举，我们只能通过假值列表做为参考来判断一个值是不是真值。</p>
<blockquote>
<p>= 0 和 == -1 这样的写法不是很好，称为”抽象泄漏“，意思是在代码中暴露了底层的实现细节，这里指的是用-1作为失败时的返回值，这些细节应该被屏蔽掉。</p>
</blockquote>
<p>html是浏览器构建dom的蓝图，为了正确构建每个dom，浏览器还会修复它在蓝图中发现的问题。</p>
<p>像普通人一样编写代码和像忍者一样编写代码的最大区别在于是否把js当成函数式语言来理解，对这一点的认知水平决定了你编写的代码的水平。</p>
<p>对象能做的任何一件事，函数也都能做，函数也是对象，唯一的特殊之处在于它是可调用的，即函数会被调用以便执行某项动作。</p>
<p>把函数作为第一类对象，是函数式编程的第一步</p>
<p>回调函数不一定都是异步的，两码事</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/06/17/EventLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/EventLoop/" itemprop="url">EventLoop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T13:57:57+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>js是单线程的编程语言，单线程的运行环境，它有且只有一个调用栈，它每次只能够做一件事，这是单线程的意思，程序每次只可以运行一段代码</p>
<p>调用栈是一个记录当前程序所在位置的数据结构，如果当前进入了某个函数，这个函数就会被放入栈里面，如果当前离开了某个函数，这个函数就会被弹出栈外，这是栈所做的事。</p>
<pre><code>function foo() {
    throw new Error(&apos;Oops!&apos;);
}

function bar() {
    foo();
}

function baz() {
    bar();
}

baz();</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/06/16/前端框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/前端框架/" itemprop="url">框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T15:10:26+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="框架解决的问题"><a href="#框架解决的问题" class="headerlink" title="框架解决的问题"></a>框架解决的问题</h3><p>框架出现的目的并不是为了提升性能，而是为了可维护性、为了便于团队开发。但是天下没有白吃的午餐，你为了程序的可维护性，出让了一部分性能作为妥协，毕竟什么框架都没有手动原生操作性能高，因为框架要具有适普性，要能处理各种各样的场景.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2020/02/10/byte和bit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/10/byte和bit/" itemprop="url">基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-10T17:04:03+08:00">
                2020-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="byte和bit"><a href="#byte和bit" class="headerlink" title="byte和bit"></a>byte和bit</h3><p>byte = 字节 1byte = 8bits</p>
<p>1字节=8比特</p>
<p>速度单位480mbps代表的是480兆比特/秒，它等于60兆字节/秒</p>
<p>平时所说的硬盘容量是8GB，这里的B指的是byte就是字节。</p>
<p>1KB = 1024bytes = 2^10bytes</p>
<p>1MB = 1024KB = 2^20bytes</p>
<p>常识： 与传输速度有关的b一般指的是bit，与容量有关的b一般指的是byte.</p>
<p>另外：usb2.0的传输速度 480mbps = 60MB/S的传输速度还只是理论值，它还要受到系统环境的制约，其实际的读写速度约在11~16mb/s。</p>
<p>Bit意为‘位’或者‘比特’是计算机运算的基础；Byte意为‘字节‘，是计算机文件大小的基本计算单位。</p>
<p>显示器的bit值只会影响到色彩过渡时候的平滑程度，与显示器本身的色域是没有多大关系的。</p>
<h3 id="Data-URI-Scheme优缺点"><a href="#Data-URI-Scheme优缺点" class="headerlink" title="Data URI Scheme优缺点"></a>Data URI Scheme优缺点</h3><p>优点</p>
<ul>
<li>减少资源请求链接数</li>
<li>当访问外部资源很麻烦或者受限的时候，可以很好的利用Data URI Scheme</li>
</ul>
<p>缺点</p>
<ul>
<li>Data URL形式的图片不会被浏览器缓存，这意味着每次访问页面都会被下载一次，但是可以通过css文件的background-image样式规则使用Data URI Scheme，使其随css文件一同被浏览器缓存起来</li>
<li>base64编码的体积是原数据的4/3，也就是说Data URL形式的图片会比二进制格式的图片体积大1/3</li>
<li>移动端性能比较低。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王晓宇</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王晓宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
