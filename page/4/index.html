<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="秋夜已凉 02">
<meta property="og:url" content="https://coffeeandtea.github.io/page/4/index.html">
<meta property="og:site_name" content="秋夜已凉 02">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秋夜已凉 02">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://coffeeandtea.github.io/page/4/">





  <title>秋夜已凉 02</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">秋夜已凉 02</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">博客年久失修还是来点音乐吧～～ 去 <a href="http://music.xiaoyu.work" target="_blank">http://music.xiaoyu.work</a> 都是你爱听的🎵～</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2019/07/22/缓存代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/缓存代理/" itemprop="url">缓存代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T09:58:08+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h3><p>缓存 + 代理 = ‘缓存代理’</p>
<p>针对“读多写少’的数据，例如突发的热点新闻、爆款商品的详情页，一秒钟内可能有成千上万次的请求，即使仅仅只缓存几秒钟，也能</p>
<p>够把巨大的访问流量挡在外面，让RPS（request pre second）降低好几个数量级，减轻应用服务器的并发压力，对性能的改善是非常显著的。</p>
<p>加入缓存后，代理服务器收到源服务器发来的响应数据后需要做两件事。</p>
<ul>
<li>第一个当然是把报文转发给客户</li>
<li>第二就是把报文存入自己的Cache里</li>
</ul>
<p>下次再有相同的请求的时候，代理服务器就可以直接发送304或者缓存数据，不必再从源服务器那里获取。</p>
<h3 id="private和public"><a href="#private和public" class="headerlink" title="private和public"></a>private和public</h3><p>为了区分客户端上的缓存和代理上的缓存。</p>
<ul>
<li>private: 表示缓存只能再客户端保存，是用户私有的，不能放在代理上与别人共享</li>
<li>public: 表示缓存完全是</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2019/07/21/代理t/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/代理t/" itemprop="url">代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T12:47:36+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>服务本身不产生内容，而是处于中间位置，转发上下游的请求和响应，具有双重身份。当面向下游的用户的时候，表现为服务器，代表源服务器响应客户端的请求；而面向上游的源服务器的时候，又表现为客户端，代表客户端发送请求。</p>
<h3 id="为什么要有代理？代理能干什么、带来什么好处？"><a href="#为什么要有代理？代理能干什么、带来什么好处？" class="headerlink" title="为什么要有代理？代理能干什么、带来什么好处？"></a>为什么要有代理？代理能干什么、带来什么好处？</h3><p>“计算机领域里的任何问题，都可以引入一个中间层来解决” TCP/IP协议栈是这样，代理也是这样。<br>代理处在HTTP通信的中间位置，对上屏蔽真实的客户端，对下屏蔽真实的服务器—–<strong><strong>欺上瞒下</strong></strong><br>在这个中间的<strong>小天地</strong>里，可以做很多有趣的事情。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>代理最基本的一个功能就是<strong>负载均衡</strong>，因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器究竟有多少台、是哪些ip地址都不知道，于是代理服务器就可以掌握请求分发的大权，决定由后面的哪台服务器来响应请求。</p>
<p><strong>轮询、一致性哈希</strong>等代理中常用的负载均衡算法的目标都是尽量把外部的流量合理的分散到多台源服务器<br>，提高系统的整体资源利用率和性能。</p>
<p>除了负载均衡，代理服务器还可以执行更多的功能：</p>
<ul>
<li>健康检查； 使用<em>心跳</em>机制监控后端服务器，发现有故障就及时<em>踢出</em>集群，保证服务高可用</li>
<li>安全防护： 保护被代理的后端服务器，限制ip地址或流量，抵御网络攻击和过载</li>
<li>加密卸载： 对外网使用ssl/tls加密通信认证，而在安全的内网不加密，消除加解密成本</li>
<li>数据过滤： 拦截上下行的数据，任意指定策略修改请求或者响应</li>
<li>内容缓存： 暂存、复用服务器响应</li>
</ul>
<h4 id="一个可能的缺点"><a href="#一个可能的缺点" class="headerlink" title="一个可能的缺点"></a>一个可能的缺点</h4><p>代理有很多的好处，但是它<strong>欺上瞒下</strong>的特点，隐藏了真实的客户端和服务器，如果双方希望获取<br>到这些“真实”的原始信息该怎么办呢？</p>
<p>首先，代理服务器需要使用字段<strong>Via</strong>标明代理的身份。</p>
<p>Via是一个通用的字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把<br>自身的信息追加到字段的末尾，就像是经手人盖了一个章。如果通信线路中有很多中间代理，就会在<br>Via里形成一个链表，这样就可以知道报文究竟走过了多少个代理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2019/07/21/缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/缓存/" itemprop="url">缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T12:46:29+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="服务器的缓存控制"><a href="#服务器的缓存控制" class="headerlink" title="服务器的缓存控制"></a>服务器的缓存控制</h3><ul>
<li>浏览器发现缓存中没有数据，于是发送请求，向服务器获取资源</li>
<li>服务器响应请求，返回资源，同时标记资源的有效期</li>
<li>浏览器缓存资源，等待下次重用</li>
</ul>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>里面的值max-age=30就是资源的有效时间只有30秒，相当于告诉浏览器，这个页面只能缓存30秒，之后就过期了，不能用。</p>
<p>注意： max-age是<strong>生存时间</strong>，又叫做新鲜度，它的时间的计算起点是响应报文的创建时间，也就是数据离开服务器的时刻，而不是客户端收到报文的时刻，所以如果数据在传输的过程中耗费了大量的时间，到达客户端的时候存活时间就没有30秒了。</p>
<h3 id="其他几个缓存控制属性"><a href="#其他几个缓存控制属性" class="headerlink" title="其他几个缓存控制属性"></a>其他几个缓存控制属性</h3><ul>
<li>no_store: 买来的西瓜不允许放冰箱，要么立刻吃掉，要么立刻扔掉</li>
<li>no_cache: 可以放进冰箱，但吃之前必须向超市询问有没有更新鲜的，有就吃超市里的。</li>
<li>must-revalidate: 可以放进冰箱，保鲜期内可以吃，过期了就要问超市还让不让吃。</li>
</ul>
<h3 id="关于Cache-Control"><a href="#关于Cache-Control" class="headerlink" title="关于Cache-Control"></a>关于Cache-Control</h3><p>不止服务器可以发送”Cache-Control”头,浏览器也可以发送”Cache-Control”头，</p>
<p>就是说请求-应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。</p>
<p>当你点击浏览器的“刷新”按钮的时候，浏览器会在请求头里面加一个<br><em>Cache-Control:max-age=0</em>因为max-age是生存时间，max-age=0的意思就是<br>“我要一个最最新鲜的西瓜”，而本地缓存里的数据至少保存了几秒钟了，所以<br>浏览器就不会使用缓存，而是向服务器发送请求。服务器看到max-age=0也就会用一个<br>最新生成的报文回应浏览器。</p>
<p>而Ctrl+F5的“强制刷新” 其实是发送了一个Cache-Control:no-cache<br>含义和max-age=0基本一样。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2019/07/20/https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/https/" itemprop="url">https? ssl/tls</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T01:11:38+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是安全？怎样才安全？"><a href="#什么是安全？怎样才安全？" class="headerlink" title="什么是安全？怎样才安全？"></a>什么是安全？怎样才安全？</h3><ul>
<li>机密性</li>
<li>完整性</li>
<li>身份认证</li>
<li>不可否认</li>
</ul>
<p>https除了协议名和端口号（443）这两点不同之外在语法、语义上和http完全一样。</p>
<p>https能够鉴别危险的网站，并且尽最大可能保证你的上网安全，防御黑客对信息的窃听、篡改或者“钓鱼”、伪造。</p>
<p>https的秘密在于它把层的传输协议由tcp/ip换成了ssl/tls，由Http over tcp/ip变成了http over ssl/tls,让http运行在了安全的ssl/tls协议上，收发报文不再使用Socket API,而是调用专门的安全接口。</p>
<h3 id="ssl-tls"><a href="#ssl-tls" class="headerlink" title="ssl/tls"></a>ssl/tls</h3><p>ssl—安全套接层，在osi模型中处于第五层，由网景公司于1994年发明，有v2和v3两个版本，而v1版本因为有严重的缺陷从未公开过。</p>
<p>ssl发展到v3时期已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组IETF在1999年把它改名为tls（传输层安全），正式标准化，版本号重新从1.0算起，所以其实TLS1.0就是SSLv3.1。</p>
<p>今天的tls已经发行了有三个版本，2006年的1.1、 2008年的1.2、和2018年的1.3,每个新版本都紧跟着密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域的权威标准。</p>
<p>目前应用最为广泛的tls是1.2，而之前的协议都已经被认为是不安全的，各大浏览器即将在2020年左右停止支持。</p>
<p>tls由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>
<p>浏览器和服务器在使用tls建立连接的时候需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为密码套件。</p>
<h5 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h5><p>是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它来作为底层库来实现tls功能，包括常用的web服务器Apache、Nginx等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/03/29/PropTypes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/PropTypes/" itemprop="url">PropTypes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T00:26:33+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h3><p>在React15.5版本之后，React的校验工作转移到了一个单独的库。<br>使用的时候安装prop-types库，它会导出一系列的验证器，用于确保收到的数据是有效的。</p>
<p>有如下不同的验证器：</p>
<pre><code>import PropTypes from &apos;prop-types&apos;;

MyComponents.propTypes = {
// 你可以指定某一个prop是一个特定的js类型，默认情况下这些都是可选的
  optionalArray: PropTypes.array,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,

  optionalNode: PropTypes.node, // 该类型的prop代表的是一个节点
  optionalElement: PropTypes.element,  // 代表一个React element 
  optionalMessage: PropTypes.instanceOf(Message), // 声明这是一个类的实例

  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]), // 保证值在某一个确定的范围内

optionalUnion: PropTypes.oneOfType([
PropTypes.string,
PropTypes.number,
PropTypes.instanceOf(Message)
  ]),                     // 保证是其中的一种类型的一个对象
  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),  // 某种特定类型的数组
      optionalObjectOf: PropTypes.objectOf(PropTypes.number),// 具有某种特定类型属性的对象
      optionalObjectWithShape: PropTypes.shape({
color: PropTypes.string,
fontSize: PropTypes.number
  }),      // 直接指定长成什么样子的对象
 requiredFunc: PropTypes.func.isRequired,    // 可以在后面追加isRequired 来确保提供指定类型的prop（如果没有指定就会发出警告）
 requiredAny: PropTypes.any.isRequired,    // 代表任意类型的数据（但是必须要有）

 // 下面是一个自定义验证器
 customProp: function(props, propName, componentName) {
if (!/matchme/.test(props[propName])) {
  return new Error(
    &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +
    &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;
  );
}
  },
      customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
    if (!/matchme/.test(propValue[key])) {
      return new Error(
        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +
        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;
      );
    }
  })
};
}</code></pre><h3 id="可以指定默认的属性"><a href="#可以指定默认的属性" class="headerlink" title="可以指定默认的属性"></a>可以指定默认的属性</h3><pre><code>class Greeting extends React.Component {
  render() {
    return (
      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
    );
  }
}

    // Specifies the default values for props:
Greeting.defaultProps = {
  name: &apos;Stranger&apos;
};

// Renders &quot;Hello, Stranger&quot;:
ReactDOM.render(
  &lt;Greeting /&gt;,
  document.getElementById(&apos;example&apos;)
);


默认属性可以保证当组件不能从父组件获取属性的时候，可以有一个默认的属性，然后我们配置的属性验证器照样会对默认属性做检查。</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/03/29/www/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/www/" itemprop="url">www</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T00:25:56+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>www是Internet的多媒体信息查询工具。<br>Nginx是一个高性能的http和反向代理服务器，也是一个imp/pop3/smtp代理服务器。</p>
<p>由内核和模块组成，其中内核的设计非常的简单和微小，仅仅通过配置文件将客户端请求映射到一个location block而在这个location中所配置的。</p>
<p>Nginx后端反向代理能力强。占用内存很低。</p>
<p>后端有健康检查功能。<br>支持phpcgi  fastcgi</p>
<p>官方测试并发能力每秒5万。</p>
<p>代码简洁容易上手</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul>
<li>核心模块： http模块 Event模块 mail模块</li>
<li>基础模块: http Access 模块  http fastCGI 模块  http Proxy模块 http Rewrite模块</li>
<li>第三方模块： http Upstream Request Hash 模块 Notice模块 和http Access Key模块。</li>
</ul>
<p>Nginx的高并发得益于其采用了epoll模型，与传统的服务器程序架构不同 epoll模型是Linux内核2.6以后才出现的。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装pcre正则支持</p>
<pre><code>yum install pcre-devel -y</code></pre><p>解压</p>
<pre><code>tar xzf nginx-1.6.2.tar.gz</code></pre><p>修改服务器版本号</p>
<pre><code>cd nginx-1.6.2;
sed -i -e&apos;s/1.6.2//g&apos; -e&apos;s/nginx\//WS/g&apos; -e&apos;s/&quot;NGINX&quot;/&quot;WS&quot;/g&apos; src/core/nginx.h</code></pre><p>make </p>
<p>make install</p>
<p>ps -ef | grep nginx     //查看是否启动</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/03/28/VueSSR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/VueSSR/" itemprop="url">VueSSR</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T23:06:31+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="VueSSR"><a href="#VueSSR" class="headerlink" title="VueSSR"></a>VueSSR</h3><pre><code>runlnNewContext false</code></pre><h3 id="什么是ssr"><a href="#什么是ssr" class="headerlink" title="什么是ssr?"></a>什么是ssr?</h3><p>默认情况下vue是构建客户端应用程序的框架，可以在浏览器中输出Vue组件，进行生成Dom的操作，然而，也可以将同一个组件渲染为服务器端的html字符串，将他们直接发送到浏览器，最后将静态标记‘混合’为客户端上完全交互的应用程序。</p>
<p>服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><p>更好的seo Google 和 Bing可以很好的对同步javascript应用程序进行索引。同步是关键，如果你的应用程序初始展示菊花图，然后通过ajax获取内容，抓取工具不会等到异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。</p>
</li>
<li><p>更快的内容到达时间。（time-to-content）对于那些「内容到达时间(time-to-content)与转化率直接相关」的应用程序而言，服务器端渲染(SSR)至关重要。<br>需要权衡的地方：</p>
</li>
<li><p>开发条件所限制，浏览器特定的代码，只能在特定的生命周期中使用；一些外部扩展库(external library)可能需要特殊处理，才能在服务器渲染应用程序中运行。</p>
</li>
<li><p>涉及构建及部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序(SPA)不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</p>
</li>
<li><p>更多的服务端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源(CPU-intensive - CPU 密集)，因此如果你预料在高流量环境(high traffic)下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
</li>
</ul>
<p> 还有可能会用到预渲染</p>
<p>模版插值</p>
<p>在纯客户端应用程序中，每个用户会在他们各自的浏览器中使用新的应用程序实例，对于服务器端渲染，我们希望也是如此：每个请求都是全新的，独立的应用程序示例，以便不会有交叉请求造成的状态污染。</p>
<p>禁用响应式数据</p>
<p>生命周期钩子函数：   只会用到beforeCreate 和 created 会用到。</p>
<p>这就是说任何其他生命周期钩子函数中的代码（例如 beforeMount 或 mounted），只会在客户端执行。</p>
<p>此外还需要注意的是，你应该避免在 beforeCreate 和 created 生命周期时产生全局副作用的代码，例如在其中使用 setInterval 设置 timer。在纯客户端(client-side only)的代码中，我们可以设置一个 timer，然后在 beforeDestroy 或 destroyed 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，请将副作用代码移动到 beforeMount 或 mounted 生命周期中。</p>
<p>通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 window 或 document，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。</p>
<p>对于共享于服务器和客户端，但用于不同平台 API 的任务(task)，建议将平台特定实现包含在通用 API 中，或者使用为你执行此操作的 library。例如，axios 是一个 HTTP 客户端，可以向服务器和客户端都暴露相同的 API。</p>
<p>对于仅浏览器可用的 API，通常方式是，在「纯客户端(client-only)」的生命周期钩子函数中惰性访问(lazily access)它们。</p>
<p>请注意，考虑到如果第三方 library 不是以上面的通用用法编写，则将其集成到服务器渲染的应用程序中，可能会很棘手。你可能要通过模拟(mock)一些全局变量来使其正常运行，但这只是 hack 的做法，并且可能会干扰到其他 library 的环境检测代码。</p>
<p>避免状态单例</p>
<p>需要提前知道哪些组件有ajax请求，等把这些请求都返回了数据之后，才开始组件的渲染。</p>
<p>是否必须使用vueX是的，当预先获取到ajax的数据后，Vue组件还没开始渲染，所以，我们得把数据先存在某个地方。</p>
<p>当Vue组件开始渲染的时候，还得把数据拿出来，正确的传递到各个组件中。</p>
<p>在浏览器渲染的时候，需要正确解析window.INITIAL_STATE,并传递到各个组件中。</p>
<p>因此我们需要有这么一个独立于视图以外的地方，来存储 管理和传递数据。这就是VueX存在的理由。</p>
<p>后端已经把ajax数据转换成html数据了，为什么还需要把ajax数据通过window.INITIAL_STATE传递到前端？因为前端渲染的时候仍然需要知道这些数据。举个例子，一个组件，给他绑定一个点击事件，点击的时候，打印this.msg.现在后端是把组件html渲染出来了，但是事件的绑定肯定还是得有浏览器来完成，如果浏览器拿不到跟服务器端相同的数据，在触发点击事件的时候，这个msg字段去哪里找呢？</p>
<h3 id="反向代理的作用"><a href="#反向代理的作用" class="headerlink" title="反向代理的作用"></a>反向代理的作用</h3><ul>
<li>保护网站的安全</li>
<li>通过配置缓存功能加速web请求</li>
<li>实现负载均衡</li>
</ul>
<p>非阻塞、高并发连接：官方测试能够支撑5万并发得益于Nginx使用了最新的epoll模型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/03/28/在一个nginx上面配置多个虚拟主机的方法：/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/在一个nginx上面配置多个虚拟主机的方法：/" itemprop="url">Nginx 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T15:08:15+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Nginx-入门"><a href="#Nginx-入门" class="headerlink" title="Nginx 入门"></a>Nginx 入门</h4><p>Nginx由核心和模块组成</p>
<p>Gzip</p>
<p>Server 节点</p>
<p>一个server就是一个虚拟主机</p>
<h3 id="在一个nginx上面配置多个虚拟主机的方法："><a href="#在一个nginx上面配置多个虚拟主机的方法：" class="headerlink" title="在一个nginx上面配置多个虚拟主机的方法："></a>在一个nginx上面配置多个虚拟主机的方法：</h3><p>配置多个server</p>
<pre><code>server     {
    listen 80;
    server_name xiaoyu.work;   //这里只写域名就行了不用加协议
    root index.html;

    location / {
        root html/CoffeeandTea.github.io;  //这是一个项目
        index index.html;
    }
}

// 配置另一个项目的地址
server     {
    listen 80;
    server_name stormen.cn;  // 第二个域名
    root index.html;

    location / {
        root html/CoffeeandTea.github.io;  //这是另一个项目
        index index.html;
    }
}</code></pre><p>这样配置后，重启nginx就可以做到：访问xiaoyu.work访问的是博客的项目，访问stormen.cn访问的是另一个项目了。</p>
<p>有的网站不支持IP访问</p>
<p>apache是多线程的，它为每个请求开启一个新的线程（或者是进程，取决于你的配合）。Nginx和node.js不是多线程的，因为线程的消耗太重了，所以他们采用单线程，基于事件的，这就把处理众多连接所产出的线程/进程消耗消除了。</p>
<p>node中的模型跟浏览器中很是类似，如果有三个人同时访问一个node站点的话，三个请求的真正处理操作不在这个node线程中，这个线程运行的是event loop，把请求分发到worker线程，worker线程应该是c++实现的，完了之后再通过callback的方式把返回的结果返回给客户端。<br>可以类比于浏览器中的webapi的事件。</p>
<p>node 运行的机制：</p>
<ul>
<li>V8引擎解析javascript脚本</li>
<li>解析后的代码，调用node api</li>
<li>libuv库负责nodeAPI的执行，它将不同的任务分配给不同的线程，形成一个event loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回给用户。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/01/11/函数节流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/函数节流/" itemprop="url">函数节流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T15:51:45+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>window的resize事件不是在resize结束之后调用的，具体是怎样一个频率我们不得而知，但是却是在不停的调用，直到窗口大小不再变化。类似的机制还用鼠标的mousemove，都是在短时间内重复触发。在红包书中有专门的应对此问题的函数节流</p>
<pre><code>function throttle(method,context) {
    clearTimeout(method.tId);
    method.tId = setTimeout(function() {
        method.call(context)
    },500)
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/01/10/Functional Components/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/Functional Components/" itemprop="url">事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T09:47:35+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>js程序采用了异步事件驱动编程模型。在这种程序设计风格下，当文档，浏览器，元素，或者与之相关的对象发生某些有趣的事情时，web浏览器就会产生事件。例如，当web浏览器加载完文档，用户把鼠标指针移动到超链接上或者敲击键盘时候，web浏览器都会产生事件。如果 JavaScript 应用程序关注特定类型的事件，那么它可以注册当这类事件发生时要调用的一个或多个函数。请注意，这种风格并不只应用于 Web 编程，所有使用图形用户界面的应用程序都采用了它，它们静待某些事情发生（即，它们等待事件发生），然后它们响应。<br>请注意，事件本身并不是一个需要定义的技术名词。简而言之，事件就是 Web 浏览器通知应用程序发生了什么事情，这种在传统软件工程中被称为观察员模式。</p>
<h3 id="offsetWidth-width-clientWidth"><a href="#offsetWidth-width-clientWidth" class="headerlink" title="offsetWidth width clientWidth"></a>offsetWidth width clientWidth</h3><p>width: css中设置的大小<br>clientWidth: width + padding<br>offsetWidth: width + padding + border </p>
<p>documentElement属性返回文档的根节点<br>语法：<br>documentObject.documentElement</p>
<p>document.body   返回html dom中的body节点即 <body><br>document.documentElement  返回html dom中的root节点  即<html></html></body></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在获取scrollTop方面的差异<br>兼容方案：   var scrollTop = document.documentElement.scrollTop || docuent.body.scrollTop</p>
<h3 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h3><p>可以获取或者设置一个元素的内容垂直滚动的像素数。一个元素的scrollTop值是这个元素的顶部到它的最顶部可见内容的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的scrollTop值是0.</p>
<h3 id="html事件处理程序"><a href="#html事件处理程序" class="headerlink" title="html事件处理程序"></a>html事件处理程序</h3><p>某个元素支持额每种事件，都可以使用一个与之相应的事件处理程序同名的html特性来指定。这个特性的值应该是能够执行的javascript代码。例如要在按钮被单击时执行一些JavaScript，可以像下面这样编写代码：</p>
<pre><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(&apos;Clicked&apos;)&quot;&gt;</code></pre><h3 id="clientX-事件属性，是一个事件属性。返回当事件被触发时鼠标指针相对于浏览器页面（或者客户区）的水平坐标。客户区域指的是当前的窗口。"><a href="#clientX-事件属性，是一个事件属性。返回当事件被触发时鼠标指针相对于浏览器页面（或者客户区）的水平坐标。客户区域指的是当前的窗口。" class="headerlink" title="clientX 事件属性，是一个事件属性。返回当事件被触发时鼠标指针相对于浏览器页面（或者客户区）的水平坐标。客户区域指的是当前的窗口。"></a>clientX 事件属性，是一个事件属性。返回当事件被触发时鼠标指针相对于浏览器页面（或者客户区）的水平坐标。客户区域指的是当前的窗口。</h3><p>语法：   event.clientX</p>
<h3 id="scrollWidth-clientWidth-offsetWidth-的区别"><a href="#scrollWidth-clientWidth-offsetWidth-的区别" class="headerlink" title="scrollWidth clientWidth offsetWidth 的区别"></a>scrollWidth clientWidth offsetWidth 的区别</h3><p>说明：   scrollWidth: 对象实际内容的宽度（注意强调的是元素中的内容），会随着对象中内容超过可是区域后而变大。</p>
<p>clientWidth :对象内容的可是区域的宽度，不包括滚动条边线，除非对象元素自身的显示变大才会变大是元素自身的一个可见区域</p>
<p>offsetWidth：  对象的整体的实际宽度，跟clientWidth的区别仅仅是包括滚动条边线，同样是随着对象的显示大小的变化而变化。</p>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p>在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则this currentTarget 和 target包含相同的值。</p>
<pre><code>var btn = document.getElementById(&apos;myBtn&apos;)
btn.onclick = function(event) {
    console.log(event.currentTarget === this);  // true
    console.log(event.target === this) // true
}</code></pre><p>这个例子检测了currentTarget和target与this的值。由于click事件的目标是按钮，因此三个值是相同的，但是如果事件处理程序存在于按钮的父节点中，那么这些值是不相同的</p>
<pre><code>document.body.onclick = function(event) {
    console.log(event.currentTarget === document.body)// true
    console.log(this === document.body) // true
    console.log(event.target === document.getElementById(&apos;myBtn&apos;))   // true
}</code></pre><p>当点击这个例子中的按钮时候，this和currentTarget都等于docuent.body,因为事件处理程序是注册到这个元素上的，然而，target元素却等于按钮元素，因为它是click事件真正的目标。由于按钮上并没有注册事件处理程序，结果 click 事件就冒泡到了 document.body，在那里事件才得到了处理。</p>
<p>事件对象的 eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么 eventPhase 等于 1；如果事件处理程序处于目标对象上，则 eventPhase 等于 2；如果是在冒泡阶段调用的事件处理程序，eventPhase 等于 3。这里要注意的是，尽管“处于目标”发生在冒泡阶段，但 eventPhase 仍然一直等于 2。来看下面的例子。</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);</code></pre><p>btn.onclick = function(event){<br>    console.log(event.eventPhase); // 2<br>};<br>document.body.addEventListener(“click”, function(event){<br>    console.log(event.eventPhase); // 1<br>}, true);<br>document.body.onclick = function(event){<br>    console.log(event.eventPhase); // 3<br>};</p>
<p>当单击这个例子中的按钮时，首先执行的事件处理程序是在捕获阶段触发的添加到 document.body 中的那一个，结果会弹出一个警告框显示表示 eventPhase 的 1。接着，会触发在按钮上注册的事件处理程序，此时的 eventPhase 值为 2。最后一个被触发的事件处理程序，是在冒泡阶段执行的添加到 document.body 上的那一个，显示 eventPhase 的值为 3。而当 eventPhase 等于 2 时，this、target 和 currentTarget 始终都是相等的</p>
<p>只有在事件处理程序执行期间，event对象才会存在，一旦事件处理程序执行完毕，event对象就会销毁</p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><pre><code>    class Square extends React.Component {
  render() {
    return (
      &lt;button className=&quot;square&quot; onClick={() =&gt; alert(&apos;click&apos;)}&gt;
        {this.props.value}
      &lt;/button&gt;
    );
  }
}</code></pre><p>Doing onClick={alert(‘click’)} would alert immediately instead of when the button is clicked.</p>
<p>意思是说做事件绑定的时候如果直接写onClick={alert(‘click’)}是不对的会在你没有点击之前直接就执行了。因为在{}中的是js是会立即执行的。onClick只是React中的一个标记，是React认识的标志，React在编译的时候肯定会搜集这些标记来翻译成浏览器中的click事件。</p>
<p>In JavaScript classes, you need to explicitly call super(); when defining the constructor of a subclass.</p>
<p>在定义一个子类的constructor的时候务必记得要调用super();</p>
<pre><code>    class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }

  render() {
    return (
      &lt;button className=&quot;square&quot; onClick={() =&gt; alert(&apos;click&apos;)}&gt;
        {this.props.value}
      &lt;/button&gt;
    );
  }
}</code></pre><p>用state来代替props</p>
<pre><code>        class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }

  render() {
    return (
      &lt;button className=&quot;square&quot; onClick={() =&gt; this.setState({value: &apos;X&apos;})}&gt;
        {this.state.value}
      &lt;/button&gt;
    );
  }
}</code></pre><p>Whenever this.setState is called, an update to the component is scheduled, causing React to merge in the passed state update and rerender the component along with its descendants.</p>
<p>每当this.setState方法被调用的时候，react就会根据最新的state来进行一次更新。</p>
<p>When you want to aggregate data from multiple children or to have two child components communicate with each other, move the state upwards so that it lives in the parent component. The parent can then pass the state back down to the children via props, so that the child components are always in sync with each other and with the parent.</p>
<p>当想要两个字组件交流或者父亲组件做一个数据的统计的时候，要move the state upwards 就是将state传递到父组件中去。</p>
<p>Now we need to change what happens when a square is clicked. The Board component now stores which squares are filled, which means we need some way for Square to update the state of Board.<br>Since component state is considered private, we can’t update Board’s state directly from Square.</p>
<p>state是组件私有的，我们不能直接在另一个组件中改变其他组件的state</p>
<p>The usual pattern here is pass down a function from Board to Square that gets called when the square is clicked. </p>
<p>通常的处理方式是父组件pass down 一个方法给子组件来调用</p>
<p>There are generally two ways for changing data. The first method is to mutate the data by directly changing the values of a variable. The second method is to replace the data with a new copy of the object that also includes desired changes.</p>
<p>有两种改变数据的方式：第一种是直接修改原始数据，第二种是创建一个新的备份。</p>
<p>第一种：直接修改</p>
<pre><code>var player = {score: 1,name:&apos;xiaoyu&apos;};
player.score = 2;
// 现在player = {score: 2,name: &apos;xiaoyu&apos;};</code></pre><p>第二种：创建备份</p>
<pre><code>var player = {score: 1, name: &apos;xiaoyu&apos;};
var newPlayer = Object.assign({},player,{score:2});
现在没有改变原来的player对象而是创建了一个新的对象</code></pre><p>虽然两种方式的最终结果是一样的，但是第二种方式可以帮助我们提高组件的性能。</p>
<h3 id="好处1-Easier-Undo-Redo-and-Time-Travel"><a href="#好处1-Easier-Undo-Redo-and-Time-Travel" class="headerlink" title="好处1: Easier Undo/Redo and Time Travel"></a>好处1: Easier Undo/Redo and Time Travel</h3><p>Immutability also makes some complex features much easier to implement. For example, further in this tutorial we will implement time travel between different stages of the game. Avoiding data mutations lets us keep a reference to older versions of the data, and switch between them if we need to.</p>
<p>更加方便的回退。我们可以保持对旧版本数据的引用，从而更加从容的在新旧状态之间来回切换。</p>
<h3 id="好处2：-Tracking-Changes-跟踪变化"><a href="#好处2：-Tracking-Changes-跟踪变化" class="headerlink" title="好处2： Tracking Changes 跟踪变化"></a>好处2： Tracking Changes 跟踪变化</h3><p>Determining if a mutated object has changed is complex because changes are made directly to the object. This then requires comparing the current object to a previous copy, traversing the entire object tree, and comparing each variable and value. This process can become increasingly complex.</p>
<p>Determining how an immutable object has changed is considerably easier. If the object being referenced is different from before, then the object has changed. That’s it.</p>
<p>如果采用直接在原来的数据对象中修改的方式，那么当发生一个改变的时候要前后对数据对象进行对比找到做了改变的地方，而采用方式二则容易判断多了 ，只要对象的引用改变了，那数据对象就改变了。如此简单。</p>
<h3 id="好处3-Determining-When-to-Re-render-in-React"><a href="#好处3-Determining-When-to-Re-render-in-React" class="headerlink" title="好处3: Determining When to Re-render in React"></a>好处3: Determining When to Re-render in React</h3><p>The biggest benefit of immutability in React comes when you build simple pure components. Since immutable data can more easily determine if changes have been made, it also helps to determine when a component requires being re-rendered.<br>To learn more about shouldComponentUpdate() and how you can build pure components take a look at Optimizing Performance.</p>
<p>最大的好处就是，当你写的组件是符合‘单一指责’的组件的时候，不改变原始数据的方式可以更加方便的判断是否发生了数据的变化继而它也更加方便的来判断是否要进行从新渲染。</p>
<h2 id="Functional-Components"><a href="#Functional-Components" class="headerlink" title="Functional Components"></a>Functional Components</h2><p>功能组件<br>We’ve removed the constructor, and in fact, React supports a simpler syntax called functional components for component types like Square that only consist of a render method. Rather than define a class extending React.Component, simply write a function that takes props and returns what should be rendered.</p>
<p>React支持一种我们称为‘功能组件‘的组件。它只包含一个render渲染函数。并且写的时候不用很麻烦的定义一个类来继承React.Component而是简单的写一个带参数的function 然后返回需要被渲染（render）的东西就可以了。<br>改写之前的组件</p>
<pre><code>function Square(props) {
    return (
        &lt;button className=&quot;square&quot; onClick={props.onClick}&gt;{props.value}&lt;/button&gt;
    )
}</code></pre><p>You’ll need to change this.props to props both times it appears. Many components in your apps will be able to be written as functional components: these components tend to be easier to write and React will optimize them more in the future.</p>
<p>大多数的组件都可以写成功能组件，这种组件写起来更加的简单并且react以后会对功能组件的优化越来越好。</p>
<p>Note that onClick={props.onClick()} would not work because it would call props.onClick immediately instead of passing it down.</p>
<p>一定要注意这里的方法调用的写法，{}中的js代码会立即执行，我们需要的是将一个函数传递下去不是直接执行这个函数。</p>
<p>We’ll want the top-level Game component to be responsible for displaying the list of moves. So just as we pulled the state up before from Square into Board, let’s now pull it up again from Board into Game – so that we have all the information we need at the top level.</p>
<p>用game组件来做一个历史的步骤的记录，就像我们将state从square提到board中去一样我们再次将state从board中提到game中去。<br>First, set up the initial state for Game by adding a constructor to it:<br>那么首先就要初始化game到state状态（既然设计到要保存状态那就要写constructor函数了，这个可以做为一个判断标准诶）</p>
<p>Then change Board so that it takes squares via props and has its own onClick prop specified by Game, like the transformation we made for Square earlier.</p>
<p>然后就要改写board了，让它从game传递出来的到props中获得squares和onClick事件属性。<br>接下来要做的：</p>
<ul>
<li>Delete the constructor in Board.</li>
<li>Replace this.state.squares[i] with this.props.squares[i] in Board’s renderSquare.</li>
<li>Replace this.handleClick(i) with this.props.onClick(i) in Board’s renderSquare.</li>
</ul>
<p>删除board中的构造函数<br>替换 this.state.squares[i] 为 this.props.squares[i]<br>替换this.handleClick(i) 为 this.props.onClick(i)</p>
<h3 id="the-keys"><a href="#the-keys" class="headerlink" title="the keys"></a>the keys</h3><p>When a key is added to the set, a component is created; when a key is removed, a component is destroyed. Keys tell React about the identity of each component, so that it can maintain the state across rerenders. </p>
<p>It’s strongly recommended that you assign proper keys whenever you build dynamic lists.</p>
<p>在生成动态列表时候一定要确保分配正确的keys<br>Component keys don’t need to be globally unique, only unique relative to the immediate siblings.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王晓宇</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王晓宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
