<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="秋夜已凉 02">
<meta property="og:url" content="https://coffeeandtea.github.io/page/4/index.html">
<meta property="og:site_name" content="秋夜已凉 02">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秋夜已凉 02">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://coffeeandtea.github.io/page/4/">





  <title>秋夜已凉 02</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">秋夜已凉 02</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">确定不来点音乐吗？去 <a href="http://music.xiaoyu.work" target="_blank">http://music.xiaoyu.work</a> 都是你爱听的🎵～</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/03/29/PropTypes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/PropTypes/" itemprop="url">PropTypes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T00:26:33+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h3><p>在React15.5版本之后，React的校验工作转移到了一个单独的库。<br>使用的时候安装prop-types库，它会导出一系列的验证器，用于确保收到的数据是有效的。</p>
<p>有如下不同的验证器：</p>
<pre><code>import PropTypes from &apos;prop-types&apos;;

MyComponents.propTypes = {
// 你可以指定某一个prop是一个特定的js类型，默认情况下这些都是可选的
  optionalArray: PropTypes.array,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,

  optionalNode: PropTypes.node, // 该类型的prop代表的是一个节点
  optionalElement: PropTypes.element,  // 代表一个React element 
  optionalMessage: PropTypes.instanceOf(Message), // 声明这是一个类的实例

  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]), // 保证值在某一个确定的范围内

optionalUnion: PropTypes.oneOfType([
PropTypes.string,
PropTypes.number,
PropTypes.instanceOf(Message)
  ]),                     // 保证是其中的一种类型的一个对象
  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),  // 某种特定类型的数组
      optionalObjectOf: PropTypes.objectOf(PropTypes.number),// 具有某种特定类型属性的对象
      optionalObjectWithShape: PropTypes.shape({
color: PropTypes.string,
fontSize: PropTypes.number
  }),      // 直接指定长成什么样子的对象
 requiredFunc: PropTypes.func.isRequired,    // 可以在后面追加isRequired 来确保提供指定类型的prop（如果没有指定就会发出警告）
 requiredAny: PropTypes.any.isRequired,    // 代表任意类型的数据（但是必须要有）

 // 下面是一个自定义验证器
 customProp: function(props, propName, componentName) {
if (!/matchme/.test(props[propName])) {
  return new Error(
    &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +
    &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;
  );
}
  },
      customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
    if (!/matchme/.test(propValue[key])) {
      return new Error(
        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +
        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;
      );
    }
  })
};
}</code></pre><h3 id="可以指定默认的属性"><a href="#可以指定默认的属性" class="headerlink" title="可以指定默认的属性"></a>可以指定默认的属性</h3><pre><code>class Greeting extends React.Component {
  render() {
    return (
      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
    );
  }
}

    // Specifies the default values for props:
Greeting.defaultProps = {
  name: &apos;Stranger&apos;
};

// Renders &quot;Hello, Stranger&quot;:
ReactDOM.render(
  &lt;Greeting /&gt;,
  document.getElementById(&apos;example&apos;)
);


默认属性可以保证当组件不能从父组件获取属性的时候，可以有一个默认的属性，然后我们配置的属性验证器照样会对默认属性做检查。</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/03/29/www/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/www/" itemprop="url">www</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T00:25:56+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>www是Internet的多媒体信息查询工具。<br>Nginx是一个高性能的http和反向代理服务器，也是一个imp/pop3/smtp代理服务器。</p>
<p>由内核和模块组成，其中内核的设计非常的简单和微小，仅仅通过配置文件将客户端请求映射到一个location block而在这个location中所配置的。</p>
<p>Nginx后端反向代理能力强。占用内存很低。</p>
<p>后端有健康检查功能。<br>支持phpcgi  fastcgi</p>
<p>官方测试并发能力每秒5万。</p>
<p>代码简洁容易上手</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul>
<li>核心模块： http模块 Event模块 mail模块</li>
<li>基础模块: http Access 模块  http fastCGI 模块  http Proxy模块 http Rewrite模块</li>
<li>第三方模块： http Upstream Request Hash 模块 Notice模块 和http Access Key模块。</li>
</ul>
<p>Nginx的高并发得益于其采用了epoll模型，与传统的服务器程序架构不同 epoll模型是Linux内核2.6以后才出现的。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装pcre正则支持</p>
<pre><code>yum install pcre-devel -y</code></pre><p>解压</p>
<pre><code>tar xzf nginx-1.6.2.tar.gz</code></pre><p>修改服务器版本号</p>
<pre><code>cd nginx-1.6.2;
sed -i -e&apos;s/1.6.2//g&apos; -e&apos;s/nginx\//WS/g&apos; -e&apos;s/&quot;NGINX&quot;/&quot;WS&quot;/g&apos; src/core/nginx.h</code></pre><p>make </p>
<p>make install</p>
<p>ps -ef | grep nginx     //查看是否启动</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/03/28/VueSSR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/VueSSR/" itemprop="url">VueSSR</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T23:06:31+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="VueSSR"><a href="#VueSSR" class="headerlink" title="VueSSR"></a>VueSSR</h3><pre><code>runlnNewContext false</code></pre><h3 id="什么是ssr"><a href="#什么是ssr" class="headerlink" title="什么是ssr?"></a>什么是ssr?</h3><p>默认情况下vue是构建客户端应用程序的框架，可以在浏览器中输出Vue组件，进行生成Dom的操作，然而，也可以将同一个组件渲染为服务器端的html字符串，将他们直接发送到浏览器，最后将静态标记‘混合’为客户端上完全交互的应用程序。</p>
<p>服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><p>更好的seo Google 和 Bing可以很好的对同步javascript应用程序进行索引。同步是关键，如果你的应用程序初始展示菊花图，然后通过ajax获取内容，抓取工具不会等到异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。</p>
</li>
<li><p>更快的内容到达时间。（time-to-content）对于那些「内容到达时间(time-to-content)与转化率直接相关」的应用程序而言，服务器端渲染(SSR)至关重要。<br>需要权衡的地方：</p>
</li>
<li><p>开发条件所限制，浏览器特定的代码，只能在特定的生命周期中使用；一些外部扩展库(external library)可能需要特殊处理，才能在服务器渲染应用程序中运行。</p>
</li>
<li><p>涉及构建及部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序(SPA)不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</p>
</li>
<li><p>更多的服务端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源(CPU-intensive - CPU 密集)，因此如果你预料在高流量环境(high traffic)下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
</li>
</ul>
<p> 还有可能会用到预渲染</p>
<p>模版插值</p>
<p>在纯客户端应用程序中，每个用户会在他们各自的浏览器中使用新的应用程序实例，对于服务器端渲染，我们希望也是如此：每个请求都是全新的，独立的应用程序示例，以便不会有交叉请求造成的状态污染。</p>
<p>禁用响应式数据</p>
<p>生命周期钩子函数：   只会用到beforeCreate 和 created 会用到。</p>
<p>这就是说任何其他生命周期钩子函数中的代码（例如 beforeMount 或 mounted），只会在客户端执行。</p>
<p>此外还需要注意的是，你应该避免在 beforeCreate 和 created 生命周期时产生全局副作用的代码，例如在其中使用 setInterval 设置 timer。在纯客户端(client-side only)的代码中，我们可以设置一个 timer，然后在 beforeDestroy 或 destroyed 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，请将副作用代码移动到 beforeMount 或 mounted 生命周期中。</p>
<p>通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 window 或 document，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。</p>
<p>对于共享于服务器和客户端，但用于不同平台 API 的任务(task)，建议将平台特定实现包含在通用 API 中，或者使用为你执行此操作的 library。例如，axios 是一个 HTTP 客户端，可以向服务器和客户端都暴露相同的 API。</p>
<p>对于仅浏览器可用的 API，通常方式是，在「纯客户端(client-only)」的生命周期钩子函数中惰性访问(lazily access)它们。</p>
<p>请注意，考虑到如果第三方 library 不是以上面的通用用法编写，则将其集成到服务器渲染的应用程序中，可能会很棘手。你可能要通过模拟(mock)一些全局变量来使其正常运行，但这只是 hack 的做法，并且可能会干扰到其他 library 的环境检测代码。</p>
<p>避免状态单例</p>
<p>需要提前知道哪些组件有ajax请求，等把这些请求都返回了数据之后，才开始组件的渲染。</p>
<p>是否必须使用vueX是的，当预先获取到ajax的数据后，Vue组件还没开始渲染，所以，我们得把数据先存在某个地方。</p>
<p>当Vue组件开始渲染的时候，还得把数据拿出来，正确的传递到各个组件中。</p>
<p>在浏览器渲染的时候，需要正确解析window.INITIAL_STATE,并传递到各个组件中。</p>
<p>因此我们需要有这么一个独立于视图以外的地方，来存储 管理和传递数据。这就是VueX存在的理由。</p>
<p>后端已经把ajax数据转换成html数据了，为什么还需要把ajax数据通过window.INITIAL_STATE传递到前端？因为前端渲染的时候仍然需要知道这些数据。举个例子，一个组件，给他绑定一个点击事件，点击的时候，打印this.msg.现在后端是把组件html渲染出来了，但是事件的绑定肯定还是得有浏览器来完成，如果浏览器拿不到跟服务器端相同的数据，在触发点击事件的时候，这个msg字段去哪里找呢？</p>
<h3 id="反向代理的作用"><a href="#反向代理的作用" class="headerlink" title="反向代理的作用"></a>反向代理的作用</h3><ul>
<li>保护网站的安全</li>
<li>通过配置缓存功能加速web请求</li>
<li>实现负载均衡</li>
</ul>
<p>非阻塞、高并发连接：官方测试能够支撑5万并发得益于Nginx使用了最新的epoll模型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/03/28/在一个nginx上面配置多个虚拟主机的方法：/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/在一个nginx上面配置多个虚拟主机的方法：/" itemprop="url">Nginx 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T15:08:15+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Nginx-入门"><a href="#Nginx-入门" class="headerlink" title="Nginx 入门"></a>Nginx 入门</h4><p>Nginx由核心和模块组成</p>
<p>Gzip</p>
<p>Server 节点</p>
<p>一个server就是一个虚拟主机</p>
<h3 id="在一个nginx上面配置多个虚拟主机的方法："><a href="#在一个nginx上面配置多个虚拟主机的方法：" class="headerlink" title="在一个nginx上面配置多个虚拟主机的方法："></a>在一个nginx上面配置多个虚拟主机的方法：</h3><p>配置多个server</p>
<pre><code>server     {
    listen 80;
    server_name xiaoyu.work;   //这里只写域名就行了不用加协议
    root index.html;

    location / {
        root html/CoffeeandTea.github.io;  //这是一个项目
        index index.html;
    }
}

// 配置另一个项目的地址
server     {
    listen 80;
    server_name stormen.cn;  // 第二个域名
    root index.html;

    location / {
        root html/CoffeeandTea.github.io;  //这是另一个项目
        index index.html;
    }
}</code></pre><p>这样配置后，重启nginx就可以做到：访问xiaoyu.work访问的是博客的项目，访问stormen.cn访问的是另一个项目了。</p>
<p>有的网站不支持IP访问</p>
<p>apache是多线程的，它为每个请求开启一个新的线程（或者是进程，取决于你的配合）。Nginx和node.js不是多线程的，因为线程的消耗太重了，所以他们采用单线程，基于事件的，这就把处理众多连接所产出的线程/进程消耗消除了。</p>
<p>node中的模型跟浏览器中很是类似，如果有三个人同时访问一个node站点的话，三个请求的真正处理操作不在这个node线程中，这个线程运行的是event loop，把请求分发到worker线程，worker线程应该是c++实现的，完了之后再通过callback的方式把返回的结果返回给客户端。<br>可以类比于浏览器中的webapi的事件。</p>
<p>node 运行的机制：</p>
<ul>
<li>V8引擎解析javascript脚本</li>
<li>解析后的代码，调用node api</li>
<li>libuv库负责nodeAPI的执行，它将不同的任务分配给不同的线程，形成一个event loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回给用户。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/01/11/函数节流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/函数节流/" itemprop="url">函数节流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T15:51:45+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>window的resize事件不是在resize结束之后调用的，具体是怎样一个频率我们不得而知，但是却是在不停的调用，直到窗口大小不再变化。类似的机制还用鼠标的mousemove，都是在短时间内重复触发。在红包书中有专门的应对此问题的函数节流</p>
<pre><code>function throttle(method,context) {
    clearTimeout(method.tId);
    method.tId = setTimeout(function() {
        method.call(context)
    },500)
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2018/01/10/Functional Components/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/Functional Components/" itemprop="url">事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T09:47:35+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>js程序采用了异步事件驱动编程模型。在这种程序设计风格下，当文档，浏览器，元素，或者与之相关的对象发生某些有趣的事情时，web浏览器就会产生事件。例如，当web浏览器加载完文档，用户把鼠标指针移动到超链接上或者敲击键盘时候，web浏览器都会产生事件。如果 JavaScript 应用程序关注特定类型的事件，那么它可以注册当这类事件发生时要调用的一个或多个函数。请注意，这种风格并不只应用于 Web 编程，所有使用图形用户界面的应用程序都采用了它，它们静待某些事情发生（即，它们等待事件发生），然后它们响应。<br>请注意，事件本身并不是一个需要定义的技术名词。简而言之，事件就是 Web 浏览器通知应用程序发生了什么事情，这种在传统软件工程中被称为观察员模式。</p>
<h3 id="offsetWidth-width-clientWidth"><a href="#offsetWidth-width-clientWidth" class="headerlink" title="offsetWidth width clientWidth"></a>offsetWidth width clientWidth</h3><p>width: css中设置的大小<br>clientWidth: width + padding<br>offsetWidth: width + padding + border </p>
<p>documentElement属性返回文档的根节点<br>语法：<br>documentObject.documentElement</p>
<p>document.body   返回html dom中的body节点即 <body><br>document.documentElement  返回html dom中的root节点  即<html></html></body></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在获取scrollTop方面的差异<br>兼容方案：   var scrollTop = document.documentElement.scrollTop || docuent.body.scrollTop</p>
<h3 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h3><p>可以获取或者设置一个元素的内容垂直滚动的像素数。一个元素的scrollTop值是这个元素的顶部到它的最顶部可见内容的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的scrollTop值是0.</p>
<h3 id="html事件处理程序"><a href="#html事件处理程序" class="headerlink" title="html事件处理程序"></a>html事件处理程序</h3><p>某个元素支持额每种事件，都可以使用一个与之相应的事件处理程序同名的html特性来指定。这个特性的值应该是能够执行的javascript代码。例如要在按钮被单击时执行一些JavaScript，可以像下面这样编写代码：</p>
<pre><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(&apos;Clicked&apos;)&quot;&gt;</code></pre><h3 id="clientX-事件属性，是一个事件属性。返回当事件被触发时鼠标指针相对于浏览器页面（或者客户区）的水平坐标。客户区域指的是当前的窗口。"><a href="#clientX-事件属性，是一个事件属性。返回当事件被触发时鼠标指针相对于浏览器页面（或者客户区）的水平坐标。客户区域指的是当前的窗口。" class="headerlink" title="clientX 事件属性，是一个事件属性。返回当事件被触发时鼠标指针相对于浏览器页面（或者客户区）的水平坐标。客户区域指的是当前的窗口。"></a>clientX 事件属性，是一个事件属性。返回当事件被触发时鼠标指针相对于浏览器页面（或者客户区）的水平坐标。客户区域指的是当前的窗口。</h3><p>语法：   event.clientX</p>
<h3 id="scrollWidth-clientWidth-offsetWidth-的区别"><a href="#scrollWidth-clientWidth-offsetWidth-的区别" class="headerlink" title="scrollWidth clientWidth offsetWidth 的区别"></a>scrollWidth clientWidth offsetWidth 的区别</h3><p>说明：   scrollWidth: 对象实际内容的宽度（注意强调的是元素中的内容），会随着对象中内容超过可是区域后而变大。</p>
<p>clientWidth :对象内容的可是区域的宽度，不包括滚动条边线，除非对象元素自身的显示变大才会变大是元素自身的一个可见区域</p>
<p>offsetWidth：  对象的整体的实际宽度，跟clientWidth的区别仅仅是包括滚动条边线，同样是随着对象的显示大小的变化而变化。</p>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p>在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则this currentTarget 和 target包含相同的值。</p>
<pre><code>var btn = document.getElementById(&apos;myBtn&apos;)
btn.onclick = function(event) {
    console.log(event.currentTarget === this);  // true
    console.log(event.target === this) // true
}</code></pre><p>这个例子检测了currentTarget和target与this的值。由于click事件的目标是按钮，因此三个值是相同的，但是如果事件处理程序存在于按钮的父节点中，那么这些值是不相同的</p>
<pre><code>document.body.onclick = function(event) {
    console.log(event.currentTarget === document.body)// true
    console.log(this === document.body) // true
    console.log(event.target === document.getElementById(&apos;myBtn&apos;))   // true
}</code></pre><p>当点击这个例子中的按钮时候，this和currentTarget都等于docuent.body,因为事件处理程序是注册到这个元素上的，然而，target元素却等于按钮元素，因为它是click事件真正的目标。由于按钮上并没有注册事件处理程序，结果 click 事件就冒泡到了 document.body，在那里事件才得到了处理。</p>
<p>事件对象的 eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么 eventPhase 等于 1；如果事件处理程序处于目标对象上，则 eventPhase 等于 2；如果是在冒泡阶段调用的事件处理程序，eventPhase 等于 3。这里要注意的是，尽管“处于目标”发生在冒泡阶段，但 eventPhase 仍然一直等于 2。来看下面的例子。</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);</code></pre><p>btn.onclick = function(event){<br>    console.log(event.eventPhase); // 2<br>};<br>document.body.addEventListener(“click”, function(event){<br>    console.log(event.eventPhase); // 1<br>}, true);<br>document.body.onclick = function(event){<br>    console.log(event.eventPhase); // 3<br>};</p>
<p>当单击这个例子中的按钮时，首先执行的事件处理程序是在捕获阶段触发的添加到 document.body 中的那一个，结果会弹出一个警告框显示表示 eventPhase 的 1。接着，会触发在按钮上注册的事件处理程序，此时的 eventPhase 值为 2。最后一个被触发的事件处理程序，是在冒泡阶段执行的添加到 document.body 上的那一个，显示 eventPhase 的值为 3。而当 eventPhase 等于 2 时，this、target 和 currentTarget 始终都是相等的</p>
<p>只有在事件处理程序执行期间，event对象才会存在，一旦事件处理程序执行完毕，event对象就会销毁</p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><pre><code>    class Square extends React.Component {
  render() {
    return (
      &lt;button className=&quot;square&quot; onClick={() =&gt; alert(&apos;click&apos;)}&gt;
        {this.props.value}
      &lt;/button&gt;
    );
  }
}</code></pre><p>Doing onClick={alert(‘click’)} would alert immediately instead of when the button is clicked.</p>
<p>意思是说做事件绑定的时候如果直接写onClick={alert(‘click’)}是不对的会在你没有点击之前直接就执行了。因为在{}中的是js是会立即执行的。onClick只是React中的一个标记，是React认识的标志，React在编译的时候肯定会搜集这些标记来翻译成浏览器中的click事件。</p>
<p>In JavaScript classes, you need to explicitly call super(); when defining the constructor of a subclass.</p>
<p>在定义一个子类的constructor的时候务必记得要调用super();</p>
<pre><code>    class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }

  render() {
    return (
      &lt;button className=&quot;square&quot; onClick={() =&gt; alert(&apos;click&apos;)}&gt;
        {this.props.value}
      &lt;/button&gt;
    );
  }
}</code></pre><p>用state来代替props</p>
<pre><code>        class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }

  render() {
    return (
      &lt;button className=&quot;square&quot; onClick={() =&gt; this.setState({value: &apos;X&apos;})}&gt;
        {this.state.value}
      &lt;/button&gt;
    );
  }
}</code></pre><p>Whenever this.setState is called, an update to the component is scheduled, causing React to merge in the passed state update and rerender the component along with its descendants.</p>
<p>每当this.setState方法被调用的时候，react就会根据最新的state来进行一次更新。</p>
<p>When you want to aggregate data from multiple children or to have two child components communicate with each other, move the state upwards so that it lives in the parent component. The parent can then pass the state back down to the children via props, so that the child components are always in sync with each other and with the parent.</p>
<p>当想要两个字组件交流或者父亲组件做一个数据的统计的时候，要move the state upwards 就是将state传递到父组件中去。</p>
<p>Now we need to change what happens when a square is clicked. The Board component now stores which squares are filled, which means we need some way for Square to update the state of Board.<br>Since component state is considered private, we can’t update Board’s state directly from Square.</p>
<p>state是组件私有的，我们不能直接在另一个组件中改变其他组件的state</p>
<p>The usual pattern here is pass down a function from Board to Square that gets called when the square is clicked. </p>
<p>通常的处理方式是父组件pass down 一个方法给子组件来调用</p>
<p>There are generally two ways for changing data. The first method is to mutate the data by directly changing the values of a variable. The second method is to replace the data with a new copy of the object that also includes desired changes.</p>
<p>有两种改变数据的方式：第一种是直接修改原始数据，第二种是创建一个新的备份。</p>
<p>第一种：直接修改</p>
<pre><code>var player = {score: 1,name:&apos;xiaoyu&apos;};
player.score = 2;
// 现在player = {score: 2,name: &apos;xiaoyu&apos;};</code></pre><p>第二种：创建备份</p>
<pre><code>var player = {score: 1, name: &apos;xiaoyu&apos;};
var newPlayer = Object.assign({},player,{score:2});
现在没有改变原来的player对象而是创建了一个新的对象</code></pre><p>虽然两种方式的最终结果是一样的，但是第二种方式可以帮助我们提高组件的性能。</p>
<h3 id="好处1-Easier-Undo-Redo-and-Time-Travel"><a href="#好处1-Easier-Undo-Redo-and-Time-Travel" class="headerlink" title="好处1: Easier Undo/Redo and Time Travel"></a>好处1: Easier Undo/Redo and Time Travel</h3><p>Immutability also makes some complex features much easier to implement. For example, further in this tutorial we will implement time travel between different stages of the game. Avoiding data mutations lets us keep a reference to older versions of the data, and switch between them if we need to.</p>
<p>更加方便的回退。我们可以保持对旧版本数据的引用，从而更加从容的在新旧状态之间来回切换。</p>
<h3 id="好处2：-Tracking-Changes-跟踪变化"><a href="#好处2：-Tracking-Changes-跟踪变化" class="headerlink" title="好处2： Tracking Changes 跟踪变化"></a>好处2： Tracking Changes 跟踪变化</h3><p>Determining if a mutated object has changed is complex because changes are made directly to the object. This then requires comparing the current object to a previous copy, traversing the entire object tree, and comparing each variable and value. This process can become increasingly complex.</p>
<p>Determining how an immutable object has changed is considerably easier. If the object being referenced is different from before, then the object has changed. That’s it.</p>
<p>如果采用直接在原来的数据对象中修改的方式，那么当发生一个改变的时候要前后对数据对象进行对比找到做了改变的地方，而采用方式二则容易判断多了 ，只要对象的引用改变了，那数据对象就改变了。如此简单。</p>
<h3 id="好处3-Determining-When-to-Re-render-in-React"><a href="#好处3-Determining-When-to-Re-render-in-React" class="headerlink" title="好处3: Determining When to Re-render in React"></a>好处3: Determining When to Re-render in React</h3><p>The biggest benefit of immutability in React comes when you build simple pure components. Since immutable data can more easily determine if changes have been made, it also helps to determine when a component requires being re-rendered.<br>To learn more about shouldComponentUpdate() and how you can build pure components take a look at Optimizing Performance.</p>
<p>最大的好处就是，当你写的组件是符合‘单一指责’的组件的时候，不改变原始数据的方式可以更加方便的判断是否发生了数据的变化继而它也更加方便的来判断是否要进行从新渲染。</p>
<h2 id="Functional-Components"><a href="#Functional-Components" class="headerlink" title="Functional Components"></a>Functional Components</h2><p>功能组件<br>We’ve removed the constructor, and in fact, React supports a simpler syntax called functional components for component types like Square that only consist of a render method. Rather than define a class extending React.Component, simply write a function that takes props and returns what should be rendered.</p>
<p>React支持一种我们称为‘功能组件‘的组件。它只包含一个render渲染函数。并且写的时候不用很麻烦的定义一个类来继承React.Component而是简单的写一个带参数的function 然后返回需要被渲染（render）的东西就可以了。<br>改写之前的组件</p>
<pre><code>function Square(props) {
    return (
        &lt;button className=&quot;square&quot; onClick={props.onClick}&gt;{props.value}&lt;/button&gt;
    )
}</code></pre><p>You’ll need to change this.props to props both times it appears. Many components in your apps will be able to be written as functional components: these components tend to be easier to write and React will optimize them more in the future.</p>
<p>大多数的组件都可以写成功能组件，这种组件写起来更加的简单并且react以后会对功能组件的优化越来越好。</p>
<p>Note that onClick={props.onClick()} would not work because it would call props.onClick immediately instead of passing it down.</p>
<p>一定要注意这里的方法调用的写法，{}中的js代码会立即执行，我们需要的是将一个函数传递下去不是直接执行这个函数。</p>
<p>We’ll want the top-level Game component to be responsible for displaying the list of moves. So just as we pulled the state up before from Square into Board, let’s now pull it up again from Board into Game – so that we have all the information we need at the top level.</p>
<p>用game组件来做一个历史的步骤的记录，就像我们将state从square提到board中去一样我们再次将state从board中提到game中去。<br>First, set up the initial state for Game by adding a constructor to it:<br>那么首先就要初始化game到state状态（既然设计到要保存状态那就要写constructor函数了，这个可以做为一个判断标准诶）</p>
<p>Then change Board so that it takes squares via props and has its own onClick prop specified by Game, like the transformation we made for Square earlier.</p>
<p>然后就要改写board了，让它从game传递出来的到props中获得squares和onClick事件属性。<br>接下来要做的：</p>
<ul>
<li>Delete the constructor in Board.</li>
<li>Replace this.state.squares[i] with this.props.squares[i] in Board’s renderSquare.</li>
<li>Replace this.handleClick(i) with this.props.onClick(i) in Board’s renderSquare.</li>
</ul>
<p>删除board中的构造函数<br>替换 this.state.squares[i] 为 this.props.squares[i]<br>替换this.handleClick(i) 为 this.props.onClick(i)</p>
<h3 id="the-keys"><a href="#the-keys" class="headerlink" title="the keys"></a>the keys</h3><p>When a key is added to the set, a component is created; when a key is removed, a component is destroyed. Keys tell React about the identity of each component, so that it can maintain the state across rerenders. </p>
<p>It’s strongly recommended that you assign proper keys whenever you build dynamic lists.</p>
<p>在生成动态列表时候一定要确保分配正确的keys<br>Component keys don’t need to be globally unique, only unique relative to the immediate siblings.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2017/12/29/Git2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/29/Git2/" itemprop="url">git</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T18:19:45+08:00">
                2017-12-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h4><p>软件开发中bug就像家常便饭一样，有了bug就需要修复，在git中由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接受到一个代号为001的bug的任务的时候，很自然的，你想创建一个分支issue-001来修复它，但是，当前你正在dev上进行的工作还没有提交，并不是不想提交，而是工作只进行到一半，还没法提交，预计完成还需要1天的时间但是，必须在2个小时之内修复，怎么办？幸好git提供了一个stash功能，可以把当前工作现场储藏起来，等以后恢复现场后继续工作。</p>
<pre><code>$ git stash
saved working directory and index state WIP on dev:6224937 add merge
HEAD is now at 6224937 add merge</code></pre><p>现在，用git status查看工作区，就是干净的（除非有没有被git管理的文件），因此可以放心的创建分支来修复bug，首先要确定在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支</p>
<pre><code>$ git chekcout master
Switched to branch &apos;master&apos;
Your branch is ahead of &apos;origin/master&apos; by 6 commits
$ git checkout -b issue-01
Switched to a now branch &apos;issue001&apos;</code></pre><p>现在修复bug，修复完后提交。修复完后，切换到master分支并完成合并，最后删除issue-001分支。OK现在是时候接着回到dev分支干活了。</p>
<pre><code>$ git checkout dev
Switched to branch &apos;dev&apos;</code></pre><p>此时查看分支的话，会发现工作区是干净的，刚才的工作现成存到哪里去了？可以用git stash list命令看看</p>
<pre><code>$ git stash list
stash@{0}:WIP on dev:6224937 add merge</code></pre><p>工作现场还在，git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：一个是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2017/12/28/正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/正则表达式/" itemprop="url">正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T21:27:32+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="构造函数定义"><a href="#构造函数定义" class="headerlink" title="构造函数定义"></a>构造函数定义</h4><p>接受两个参数，一个是要匹配的字符串模式（这个参数需要是字符串，不能是正则表达式字面量），另一个是标志字符串，g i m</p>
<pre><code>var reg = new RegExp(&apos;java[script]&apos;,&apos;gim&apos;)</code></pre><p>g,i,m是可选的参数，其中g：全文查找–模式被应用于所有的字符串，而不是发现第一个匹配项时就立即停止。i:忽略大小写。m:多行查找，在达到一行文本末尾时还会继续查找下一行中是否存在模式匹配的项。<br>在es3中，正则表达式字面量会始终共享一个RegExp实例，而使用构造函数创建的每个RegExp都是一个新的实例。但是在es5中正则表达式字面量和构造函数一样，都会创建新的RegExp实例。</p>
<p>replace(RegExp/str,str_replace),replace方法接受两个参数，第一个参数为字符串或者正则对象，第二个参数为字符串或一个回调函数。如果是字符串，第二个参数将会替换第一个参数匹配到的值，然后将替换后的原文本作为返回值返回。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2017/12/28/前端知识大杂烩/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/前端知识大杂烩/" itemprop="url">前端知识大杂烩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T21:26:52+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前端知识大杂烩"><a href="#前端知识大杂烩" class="headerlink" title="前端知识大杂烩"></a>前端知识大杂烩</h1><h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><p>1 判断是否来自微信浏览器</p>
<pre><code>function isFromWeiXin() {
    var ua = navigator.userAgent.toLowerCase()
    if(ua.match(/MicroMessager/i) == &apos;micromessager&apos;){
    return true
    }
    return false
}</code></pre><p>2 判断手机的类型</p>
<pre><code>var user = &apos;&apos;;
if(/android/i.test(navigator.userAgent)){
    user = &apos;1&apos;
}
if(/ipad|iphone|mac/i.test(navigator.userAgent)){
    user = &apos;0&apos;
}</code></pre><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>搜索引擎的工作原理是什么？关键字网页内查询吗？为什么可以达到如此之快的速度？<br>答：  原理通俗来讲就是搜索引擎先在网上找来所有信息，这个过程将永远不停息的进行下去，然后建立一个数据库，然后对这些信息创建一个索引，当用户来搜索的时候，直接用自己归纳编排好的索引，找自己数据库里的信息反馈给用户。</p>
<h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><p>互联网上的信息存储在无数个服务器上，任何搜索引擎想要回答用户的搜索，首先要把网页存储在自己本地的服务器上，这靠的就是网络爬虫。它不停的向各种网络发起请求，将所得到的网页存储起来。如何高效的爬取数据是一个很大的挑战，比如需要有成千上万个爬虫程序同时爬取数据，高效的将数据存储起来以便之后分析等。出于安全等因素考虑，很多网络服务器都有反恶意爬虫的功能。尽管他们所采用的策略各不相同，但是是共同点是他们的目标就是尽量只响应真人用户的请求，但是搜索引擎爬虫通常不需要担心这一点，因为大部分网站都希望提高自己的搜索排名，欢迎爬虫的到访。通常谷歌等搜索引擎和网站之间有约定，比如在网页上加一个特殊的标签，告诉爬虫这个网页是什么类型的，包含什么信息等，以便帮助爬虫更好的获取该网页的内容。</p>
<h3 id="分数、权重"><a href="#分数、权重" class="headerlink" title="分数、权重"></a>分数、权重</h3><p>。。。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>搜索引擎是各种高深的算法和复杂的系统实现的完美结合，每一部分都在系统里起到关键作用。</p>
<h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><p>确认URL以后，浏览器首先要查询域名，对应服务器的IP地址，一般需要20-120毫秒时间，浏览器缓存–&gt;本地host查询–&gt;dns服务器。dns查询完成之前，浏览器无法识别服务器IP，因此不下载任何数据。基于性能考虑，ISP运营商、局域网路由、操作系统、客户端（浏览器）都会有相应的dns缓存机制。</p>
<ul>
<li>IE 缓存 30 分钟，可以通过注册表中 DnsCacheTimeout 项设置；</li>
<li>Firefox 混存 1 分钟，通过 network.dnsCacheExpiration 配置；</li>
<li>Chrome - &gt; 设置 - &gt; 选项 - &gt; 高级选项 - &gt; 去勾 “用预提取 DNS 提高网页载入速度”</li>
</ul>
<h3 id="Favicon-ico"><a href="#Favicon-ico" class="headerlink" title="Favicon.ico"></a>Favicon.ico</h3><p>中文名称是网站头像。可以显示在网站的浏览器标签、地址栏左边和收藏夹，是展示网站个性的缩略logo标志，也可以说是网站头像，如果要让网站看起来更专业、更美、更有个性。Favicon.ico是必不可少的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2017/12/25/javascript语言精粹/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/javascript语言精粹/" itemprop="url">javascript语言精粹</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-25T20:24:06+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="javascript语言精粹"><a href="#javascript语言精粹" class="headerlink" title="javascript语言精粹"></a>javascript语言精粹</h3><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5><p>在web浏览器中每个 </p>
<pre><code>&lt;script&gt; </code></pre><p>标签提供一个被编译且立即执行的编译单元，JavaScript把它们一起抛到一个公共的全局名字空间中。<br>switch、while、for和do语句允许有一个可选的前置标签label。它配合break语句来使用。<br>for-in循环用于枚举一个对象的所有属性名。在每次循环中object的下一个属性名字符串被赋值给variale。通常需要使用object.hasOwnProperty(variable)这个方法来确定一个属性是否是该对象的成员，还是来自于原型链。</p>
<pre><code>for(myvar in obj){
    if(obj.hasOwnProperty(myvar)){
        //do something
    }
}</code></pre><p>do语句就像while语句，唯一的区别是它在代码执行之后而不是之前检测表达式的值，这就意味着代码块至少执行一次。<br>try语句执行一个代码块，并捕获该代码块抛出的任何异常。catch从句定义了一个新的变量variable来接受抛出的异常对象。<br>throw语句抛出一个异常，如果throw语句在一个try代码块中，那么控制流就会跳转到catch从句中。如果throw语句在函数中，则该函数调用被放弃，控制流跳转到调用该函数的try语句的catch从句中。throw语句中的表达式通常是一个对象字面量，包含一个name属性和一个message属性。异常捕获器可以使用这些信息去决定该做什么。return语句会导致从函数中提前返回，它也可以指定要被返回的值，如果没有指定返回的表达式，那么返回值就是undefined。JavaScript不允许在return关键字和表达式之间换行。</p>
<h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p>对象字面量是一种可以方便的按照指定规格创建新对象的表示法，属性名可以是标示符或者字符串，这些名字被当做字面量而不是变量名来对待，所以对象的属性名在编译时才能知道。属性的值就是表达式。</p>
<h3 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h3><p>JavaScript的简单数据类型包括数字 字符串 布尔值 null值和undefined值。其他所有值都是对象。数字字符串和布尔值‘貌似’对象，因为它们有方法，但是它们是不可变的。JavaScript中的对象是可变的键控集合。在JavaScript中数组是对象，函数是对象正则表达式是对象。对象是属性的容器，其中每个属性都拥有名字和值，属性的名字可以是包括空字符串在内的任意字符串。属性值可以是除了undefined值之外的任何值。<br>JavaScript包含一种原型链的特性，允许对象继承另一个对象的属性。正确的使用它能减少对象初始化时消耗的时间和内存。</p>
<h4 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h4><p>要检索对象里包含的值，可以采用在[]后缀中括住一个字符串表达式的方式。如果字符串表达式是一个字符串字面量，而且是一个合法的JavaScript标识符不是保留字，那么也可以使用.表示法来代替，优先考虑使用.</p>
<p>||  运算符可以用来填充默认值；</p>
<pre><code>var middle = stooge[&apos;middle-name&apos;] || &apos;none&apos;,
var status = flight.status || &apos;unknow&apos;</code></pre><p>尝试从undefined的成员属性中取值将会导致TypeError异常。这时可以使用&amp;&amp;运算符来避免错误。</p>
<pre><code>flight.e     // undefined
flight.e.f   // throw &quot;TypeError&quot;
flight.e &amp;&amp; flight.e.f // undefined</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>对象里的值可以通过赋值语句来更新，如果属性名已经存在在对象里了，哪儿这个属性的值就会被替换，如果对象之前没有那个属性名，那么该属性就会被扩充到对象中。</p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>每个对象都链接到一个原型对象，并且可以从中继承属性。所有通过对象字面量创建的对象都连接到Object.prototype，他是一个JavaScript中的标配对象。原型链在更新时是不起作用<code>的</code>，当我们对某个对象做出改变时，不会触及该对象的原型。原型链关系是一中动态的关系，如果我们添加一个新的属性到原型中，那么这个属性会立即对所有基于该原型的对象可见。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>delete运算符可以用来删除对象的属性，如果对象包含该属性，那么该属性就会被移除。它不会触及原型链中的任何对象。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数对象链接到Function.proptotype。（Function.proptotype再链接到Object.proptotype）每个函数在创建时候会附加两个隐藏属性：1函数的上下文和实现函数行为的代码。每个函数在创建时也随配有一个prototype属性。它的值是一个拥有constructor属性且值为该函数的对象，这个和隐藏链接到Function.prototype完全不同。<br>函数字面量可以出现在任何允许表达式出现的地方。函数也可以被定义在其他函数中，一个内部函数除了可以访问自己的参数和变量，同时它也可以自由访问把它嵌套在其中的父函数的参数和变量。通过函数字面量创建的函数对象包含一个链接到外部上下文的链接。这被称为闭包。他是JavaScript强大表现力的来源。<br>JavaScript创建一个函数的时候，会给该对象设置一个‘调用’属性，当JavaScript调用一个函数时，可以理解为调用此函数的调用属性。</p>
<h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>//创建一个名为add的变量，并用来把两个数字相加的函数赋值给它。</p>
<pre><code>var add = function(a,b){
    return a + b
}</code></pre><p>函数字面量包括四个部分：第一个部分是保留字function第二个部分是函数名（可以被省略），函数可以通过函数名来递归的调用自己。第三部分是包围在圆括号中的一组参数。多个参数用逗号隔开。第四部分是包围在花括号中的一组语句。这些语句是函数的主体，在函数被调用的时候执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王晓宇</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王晓宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
