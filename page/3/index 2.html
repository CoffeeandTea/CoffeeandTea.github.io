<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="秋夜已凉 02">
<meta property="og:url" content="https://coffeeandtea.github.io/page/3/index.html">
<meta property="og:site_name" content="秋夜已凉 02">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秋夜已凉 02">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://coffeeandtea.github.io/page/3/">





  <title>秋夜已凉 02</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">秋夜已凉 02</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">博客年久失修还是来点音乐吧～～ 去 <a href="http://music.xiaoyu.work" target="_blank">http://music.xiaoyu.work</a> 都是你爱听的🎵～</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/www/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/www/" itemprop="url">www</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:04+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>www是Internet的多媒体信息查询工具。<br>Nginx是一个高性能的http和反向代理服务器，也是一个imp/pop3/smtp代理服务器。</p>
<p>由内核和模块组成，其中内核的设计非常的简单和微小，仅仅通过配置文件将客户端请求映射到一个location block而在这个location中所配置的。</p>
<p>Nginx后端反向代理能力强。占用内存很低。</p>
<p>后端有健康检查功能。<br>支持phpcgi  fastcgi</p>
<p>官方测试并发能力每秒5万。</p>
<p>代码简洁容易上手</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul>
<li>核心模块： http模块 Event模块 mail模块</li>
<li>基础模块: http Access 模块  http fastCGI 模块  http Proxy模块 http Rewrite模块</li>
<li>第三方模块： http Upstream Request Hash 模块 Notice模块 和http Access Key模块。</li>
</ul>
<p>Nginx的高并发得益于其采用了epoll模型，与传统的服务器程序架构不同 epoll模型是Linux内核2.6以后才出现的。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装pcre正则支持</p>
<pre><code>yum install pcre-devel -y</code></pre><p>解压</p>
<pre><code>tar xzf nginx-1.6.2.tar.gz</code></pre><p>修改服务器版本号</p>
<pre><code>cd nginx-1.6.2;
sed -i -e&apos;s/1.6.2//g&apos; -e&apos;s/nginx\//WS/g&apos; -e&apos;s/&quot;NGINX&quot;/&quot;WS&quot;/g&apos; src/core/nginx.h</code></pre><p>make </p>
<p>make install</p>
<p>ps -ef | grep nginx     //查看是否启动</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/vitual-dom原理与简单实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/vitual-dom原理与简单实现/" itemprop="url">vitual-dom原理与简单实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:04+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vitual-dom原理与简单实现"><a href="#vitual-dom原理与简单实现" class="headerlink" title="vitual-dom原理与简单实现"></a>vitual-dom原理与简单实现</h2><p>有一个简单粗暴的办法，就是一旦数据发生变化，就重新绘制整个视图，也就是重新设置下innerHTML.但是问题是这样性价比太高，对于简单的局部的小数据还可以，一旦遇到大型复杂的应用就不行了，所以我们采用JavaScript的方法来模拟dom数，用新渲染的对象树去和旧的对象树进行对比，记录下变化的地方，然后应用到真实的dom树上，这样就不用全部重新渲染了，这就是虚拟dom的优势。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/vue/" itemprop="url">Vue源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:04+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h3><pre><code>Vue.prototype.$nextTick = function (fn: Function) {
    return nextTick(fn, this)
}</code></pre><p>$nextTick里面装的是一个回调函数。</p>
<p>未完待续…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/seajs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/seajs/" itemprop="url">sea.js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:04+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="seajs"><a href="#seajs" class="headerlink" title="seajs"></a>seajs</h3><p>在seajs中，所有的JavaScript模块都遵循CMD模块定义规范，该规范明确了模块的基本书写格式和基本交互规则。在CMD规范中一个模块就是一个文件。代码的书写格式如下：</p>
<pre><code>define(factory);</code></pre><h4 id="define-Function"><a href="#define-Function" class="headerlink" title="define Function"></a>define Function</h4><p>define是一个全局函数，用来定义模块。<br>define接受factory参数，factory可以是一个函数，也可以是一个对象或者字符串。factory为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以如下定义一个json数据模块：</p>
<pre><code>define（{“foo”：“bar”}）;</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/source map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/source map/" itemprop="url">source map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:04+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="从源码转换开始说起"><a href="#从源码转换开始说起" class="headerlink" title="从源码转换开始说起"></a>从源码转换开始说起</h3><p>js脚本现在变得越来越复杂，大部分源码（尤其是各种函数可和框架）都要经过转换，才能投入生产环境。常见的源码转换，主要有以下三种：</p>
<ul>
<li>压缩减少体积。比如jquery 1.9的源码，压缩前是252KB，压缩后是32KB。</li>
<li>多个文件合并，减少http请求数。</li>
<li>其他语言编译成javascript。最常见的例子就是CoffeeScript(还有各大框架的CommonJS源码)。</li>
</ul>
<p>这三种情况都使得实际运行的代码不同于开发代码，debug变得困难重重。</p>
<p>通常js解释器会告诉你第几行第几列出错了，但是这对于转换后的代码毫无用处，因为所有的变量都改了名字。你看到报错信息，毫无头绪，根本不知道他所在的位置。这，就是source map想要解决的问题。</p>
<h3 id="什么是sourcemap"><a href="#什么是sourcemap" class="headerlink" title="什么是sourcemap"></a>什么是sourcemap</h3><p>source map是一个信息文件，里面存储着位置信息，也即是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，debug工具将直接显示原始源代码，而不是转换后的代码。目前，暂时只有Chrome浏览器支持这个功能。在Developer Tools的Setting设置中，确认选择“Enable source maps”</p>
<h3 id="如何启用source-map"><a href="#如何启用source-map" class="headerlink" title="如何启用source map"></a>如何启用source map</h3><p>只要在转换后的代码尾部，加上一行就行了</p>
<p>//@ sourceMappingURL=/path/to/sourcemapfile</p>
<p>map文件可以放在网络上，也可以放在本地文件系统</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/px2rem或postcss-px2rem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/px2rem或postcss-px2rem/" itemprop="url">移动端适配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:04+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="px2rem或postcss-px2rem"><a href="#px2rem或postcss-px2rem" class="headerlink" title="px2rem或postcss-px2rem"></a>px2rem或postcss-px2rem</h3><ul>
<li>在移动端中，为了适配不同的设备，通常用rem来做适配</li>
<li>rem是通过根元素进行适配的，网页中的根元素指的是<html>，我们通过设置</html></li>
</ul>
<p>假值列表：</p>
<p>以下这些是假值</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0、-0、NaN</li>
<li>“”</li>
</ul>
<p>除了以上这些假值以外的值都是真值，也就是说没有一个真值列表，真值的列表可以无限长，无法一一列举，我们只能通过假值列表做为参考来判断一个值是不是真值。</p>
<blockquote>
<p>= 0 和 == -1 这样的写法不是很好，称为”抽象泄漏“，意思是在代码中暴露了底层的实现细节，这里指的是用-1作为失败时的返回值，这些细节应该被屏蔽掉。</p>
</blockquote>
<p>html是浏览器构建dom的蓝图，为了正确构建每个dom，浏览器还会修复它在蓝图中发现的问题。</p>
<p>像普通人一样编写代码和像忍者一样编写代码的最大区别在于是否把js当成函数式语言来理解，对这一点的认知水平决定了你编写的代码的水平。</p>
<p>对象能做的任何一件事，函数也都能做，函数也是对象，唯一的特殊之处在于它是可调用的，即函数会被调用以便执行某项动作。</p>
<p>把函数作为第一类对象，是函数式编程的第一步</p>
<p>回调函数不一定都是异步的，两码事</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/js中defer和async的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/js中defer和async的区别/" itemprop="url">js中defer和async的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:04+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="js中defer和async的区别"><a href="#js中defer和async的区别" class="headerlink" title="js中defer和async的区别"></a>js中defer和async的区别</h2><pre><code>//最原始的情况
 &lt;script src=&apos;script.js&apos;&gt;&lt;/script&gt;
 没有defer或者async，浏览器会立即加载并执行指定的脚本，‘立即’的意思是指在渲染*script*标签之后的文档元素之前，也就是不等待后续载入的文档元素，读到就加载并执行。
 //async的情况
 &lt;script asycn src=&apos;script.js&apos;&gt;&lt;/script&gt;
 有了async,加载和渲染后续文档元素的过程将和script.js的加载与执行并行进行（异步）。
 //defer的情况
 &lt;script defer src=&apos;script.js&apos;&gt;&lt;/script&gt;
 有defer,加载后续文档元素的过程将和script.js并行进行（异步），但是script.js的执行要在所有元素解析完成之后，也就是DOMContentLoaded事件触发之前完成。是的，是之前。</code></pre><p>下面是一张三种加载方式的对比图<br><img src="http://segmentfault.com/img/bVcQV0" alt="Aaron Swartz"></p>
<p>async和defer一样，不会阻塞当前文档的解析，他会异步下载脚本，但是和defer不同的是，asnync会在脚本下载完成后立即执行，如果项目中脚本之间存在依赖关系，不推荐使用async</p>
<h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><p>DOMContentLoaded与OnLoad事件，前者：页面document已经解析完成，页面中的dom元素已经可用，但是页面中引用的图片、subframe可能还没加载完。后者Onload：页面中的所有资源都加载完毕，包括图片。浏览器的载入进度在这时才会停止。这两个时间点将页面加载的timeline分成了三个阶段。</p>
<h3 id="defer-属性声明"><a href="#defer-属性声明" class="headerlink" title="defer 属性声明"></a>defer 属性声明</h3><p>其实浏览器默认加载js文件是同步阻塞的就是因为怕js文件中会有比如document.write()或者类似的dom修改，而声明了defer属性的script标签，其实就是表明，这个脚本中不会有document.write或者其他dom修改。</p>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>什么是延迟加载？    </p>
<p>延迟加载: 有些js代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。延迟加载就是一开始并不加载这些暂时用不到的js,而是在需要的时候或者稍后再通过js的控制来异步加载。也就是将js切分成很多模块，页面初始化时只加载需要立即执行的js，然后其他js的加载延迟到第一次需要用到的时候再加载。特别是页面有大量不同的模块组成，很多可能暂时不用或者根本就没用到。就像<em>图片的延迟加载</em>在图片出现在可视区域时，才加载显示图片。</p>
<h3 id="script的两个阶段：-加载和执行"><a href="#script的两个阶段：-加载和执行" class="headerlink" title="script的两个阶段： 加载和执行"></a>script的两个阶段： 加载和执行</h3><p>js的加载其实是由两个阶段组成： <em>下载内容（download bytes）</em> 和<em>执行（parse and execute）</em> 浏览器在下载完js的内容后就会立即对其解释执行，不管是同步的还是异步的。下载后都会立即执行，而浏览器在解析执行js阶段是阻塞任何操作的，这时候的浏览器处于无响应状态。我们都知道通过网络下载script需要明显的时间，单容易忽略第二阶段，解析和执行也是需要时间的，script的解析和执行所花的时间比我们想象中的要多。延迟执行的原理: 将js先异步下载缓存起来，但是不立即执行，而是在第一次需要的时候执行一次。利用特殊的技巧可以做到下载和执行的分离。比如将js的内容作为Image或者object对象加载缓存起来，这样就不会立即执行了，然后在第一次需要的时候再执行。</p>
<h3 id="script标签使用的历史"><a href="#script标签使用的历史" class="headerlink" title="script标签使用的历史"></a>script标签使用的历史</h3><p>1script放在head中</p>
<pre><code>&lt;head&gt;
    &lt;script src=&apos;..&apos;&gt;&lt;/script&gt;
&lt;/head&gt;</code></pre><p>阻止了后续的下载，在IE6-7中script是顺序下载的，而不是现在的并行下载、顺序执行的方式，在下载和执行阶组织渲染，这就是页面卡的根源！</p>
<p>2 script放在页面底部</p>
<pre><code>&lt;script src=&apos;..&apos;&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre><p>不阻止其他下载（底部/body前）<br>在IE6-7中script是顺序下载的；在下载和解析执行阶段阻止渲染</p>
<p>3 异步加载script</p>
<pre><code>var se = document.createElement(&apos;script&apos;)
se.src = &apos;http://script.js&apos;
document.getElementsByTagName(&apos;head&apos;)[0].appendChild(se)</code></pre><p>在所有浏览器中script都是并行下载，只在解析执行阶段阻止渲染</p>
<p>4 异步下载 + 按需执行（图片预加载）</p>
<pre><code>var se = new Image()
se.onload = registerScript()
se.src = &apos;http://anydomain.com/a.js&apos;</code></pre><p>将下载js和解析执行js分离出来。不阻止其他下载，在所有浏览器中script都是并行下载不阻止渲染直到真正需要时。</p>
<h3 id="异步加载的问题"><a href="#异步加载的问题" class="headerlink" title="异步加载的问题"></a>异步加载的问题</h3><p>在异步加载的时候，无法使用document.write输出文档内容<br>在同步模式下，document.write是在当前script所在位置输出文档的。而在异步模式下，浏览器继续处理后续页面的内容，根本无法确定document.write应该输出到什么位置，所以异步模式下document.write不可行。而到了页面已经onload之后，再执行document.wrire将导致当前页面的内容被清空，因为它会自动触发document.open方法。实际上docuemnt.write的名声并不好，最好少用。</p>
<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>常用于跨域请求数据的JSONP，也可以理解为一种脚本的同步加载：我们在本站声明一个回调函数，然后向外站用src请求一个js文件，文件中的代码是用外站的数据对本站函数进行调用，就实现了使用外站数据的目的。虽然函数是本站声明的，数据是外站的，外站调用本站函数，但是把它理解为同步加载和执行就简单了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/js函数式编程？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/js函数式编程？/" itemprop="url">javascript函数式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:04+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h3><h5 id="数学中的函数"><a href="#数学中的函数" class="headerlink" title="数学中的函数"></a>数学中的函数</h5><pre><code>f(x) = y</code></pre><ul>
<li>函数必须总是接受一个参数</li>
<li>函数必须总是返回一个值</li>
<li>函数应该依据接收到的参数而不是外部环境运行</li>
<li>对于一个给定的x,只会输出唯一的一个y</li>
</ul>
<pre><code>var percentValue = 5;
var calculateTex = (value) =&gt; {
    return value/100 * (100 + percentValue )）
}</code></pre><p>上面的计税函数不是一个纯函数在于它依赖了全局变量percentValue ，修复方法很简单，只需要移动全局变量percentValue ，把它作为函数的参数改写如下：</p>
<pre><code>var calculateTex = (value, percentValue ) =&gt; {
return value/100 * (100 + percentValue )
}</code></pre><p>现在calculateTex 可以被称为一个真正的纯函数了。<br>将函数对全局变量的依赖移到函数的参数中是最常见的一种“纯函数化”的方式，移除函数对全局变量的访问会使得函数的测试更加容易。</p>
<h3 id="引用透明性-（Referential-Transparency）"><a href="#引用透明性-（Referential-Transparency）" class="headerlink" title="引用透明性 （Referential Transparency）"></a>引用透明性 （Referential Transparency）</h3><p>函数对于相同的输入都将返回相同的值，这一属性被称为引用透明性。依据函数的这一属性可以直接用函数的结果替换掉函数的调用，这个过程被称为替换模型，这些特性使得并发代码和缓存称为可能。多线程和同步的问题在于对全局数据的依赖上，而遵循引用透明性的函数只依赖参数的输入而不依赖全局数据，所以线程可以自由的运行且没有锁的机制。<br>引用透明性是一种<a href="https://en.wikipedia.org/wiki/Analytical_philosophy" target="_blank" rel="noopener">分析哲学</a></p>
<h3 id="函数式编程与命令式编程的对比"><a href="#函数式编程与命令式编程的对比" class="headerlink" title="函数式编程与命令式编程的对比"></a>函数式编程与命令式编程的对比</h3><h5 id="命令式编程遍历数组"><a href="#命令式编程遍历数组" class="headerlink" title="命令式编程遍历数组"></a>命令式编程遍历数组</h5><pre><code>let array = [1,2,3]
for (let i = 0; i&lt; array.length; i++) {
console.log(array[i])
}</code></pre><h5 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h5><pre><code>let array = [1,2,3]
array.forEach(item =&gt; console.log(item))</code></pre><p>在函数式编程中我们移除了“如何做”的部分将他抽象到一个函数中（高阶函数），如此可以让开发者只需要关心手头的问题</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><ul>
<li>纯函数不应该依赖任何外部变量，同时也不应该改变任何外部变量。</li>
<li>纯函数应该像Math.max(3,4,5,6)一样，不需要看max的内部实现就能得到结果。</li>
<li>纯函数允许我们并发的执行代码，因为纯函数不会改变它的环境，意味着我们不需要关心同步的问题。</li>
<li>纯函数使缓存函数的输出避免下次重新计算成为可能</li>
<li>纯函数应该被设计成只做一件事（单一职责）就像UNIX哲学那样，我们可以通过组合或者管道来完成复杂的任务</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/javascript语言精粹/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/javascript语言精粹/" itemprop="url">javascript语言精粹</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:04+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="javascript语言精粹"><a href="#javascript语言精粹" class="headerlink" title="javascript语言精粹"></a>javascript语言精粹</h3><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5><p>在web浏览器中每个 </p>
<pre><code>&lt;script&gt; </code></pre><p>标签提供一个被编译且立即执行的编译单元，JavaScript把它们一起抛到一个公共的全局名字空间中。<br>switch、while、for和do语句允许有一个可选的前置标签label。它配合break语句来使用。<br>for-in循环用于枚举一个对象的所有属性名。在每次循环中object的下一个属性名字符串被赋值给variale。通常需要使用object.hasOwnProperty(variable)这个方法来确定一个属性是否是该对象的成员，还是来自于原型链。</p>
<pre><code>for(myvar in obj){
    if(obj.hasOwnProperty(myvar)){
        //do something
    }
}</code></pre><p>do语句就像while语句，唯一的区别是它在代码执行之后而不是之前检测表达式的值，这就意味着代码块至少执行一次。<br>try语句执行一个代码块，并捕获该代码块抛出的任何异常。catch从句定义了一个新的变量variable来接受抛出的异常对象。<br>throw语句抛出一个异常，如果throw语句在一个try代码块中，那么控制流就会跳转到catch从句中。如果throw语句在函数中，则该函数调用被放弃，控制流跳转到调用该函数的try语句的catch从句中。throw语句中的表达式通常是一个对象字面量，包含一个name属性和一个message属性。异常捕获器可以使用这些信息去决定该做什么。return语句会导致从函数中提前返回，它也可以指定要被返回的值，如果没有指定返回的表达式，那么返回值就是undefined。JavaScript不允许在return关键字和表达式之间换行。</p>
<h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p>对象字面量是一种可以方便的按照指定规格创建新对象的表示法，属性名可以是标示符或者字符串，这些名字被当做字面量而不是变量名来对待，所以对象的属性名在编译时才能知道。属性的值就是表达式。</p>
<h3 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h3><p>JavaScript的简单数据类型包括数字 字符串 布尔值 null值和undefined值。其他所有值都是对象。数字字符串和布尔值‘貌似’对象，因为它们有方法，但是它们是不可变的。JavaScript中的对象是可变的键控集合。在JavaScript中数组是对象，函数是对象正则表达式是对象。对象是属性的容器，其中每个属性都拥有名字和值，属性的名字可以是包括空字符串在内的任意字符串。属性值可以是除了undefined值之外的任何值。<br>JavaScript包含一种原型链的特性，允许对象继承另一个对象的属性。正确的使用它能减少对象初始化时消耗的时间和内存。</p>
<h4 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h4><p>要检索对象里包含的值，可以采用在[]后缀中括住一个字符串表达式的方式。如果字符串表达式是一个字符串字面量，而且是一个合法的JavaScript标识符不是保留字，那么也可以使用.表示法来代替，优先考虑使用.</p>
<p>||  运算符可以用来填充默认值；</p>
<pre><code>var middle = stooge[&apos;middle-name&apos;] || &apos;none&apos;,
var status = flight.status || &apos;unknow&apos;</code></pre><p>尝试从undefined的成员属性中取值将会导致TypeError异常。这时可以使用&amp;&amp;运算符来避免错误。</p>
<pre><code>flight.e     // undefined
flight.e.f   // throw &quot;TypeError&quot;
flight.e &amp;&amp; flight.e.f // undefined</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>对象里的值可以通过赋值语句来更新，如果属性名已经存在在对象里了，哪儿这个属性的值就会被替换，如果对象之前没有那个属性名，那么该属性就会被扩充到对象中。</p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>每个对象都链接到一个原型对象，并且可以从中继承属性。所有通过对象字面量创建的对象都连接到Object.prototype，他是一个JavaScript中的标配对象。原型链在更新时是不起作用<code>的</code>，当我们对某个对象做出改变时，不会触及该对象的原型。原型链关系是一中动态的关系，如果我们添加一个新的属性到原型中，那么这个属性会立即对所有基于该原型的对象可见。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>delete运算符可以用来删除对象的属性，如果对象包含该属性，那么该属性就会被移除。它不会触及原型链中的任何对象。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数对象链接到Function.proptotype。（Function.proptotype再链接到Object.proptotype）每个函数在创建时候会附加两个隐藏属性：1函数的上下文和实现函数行为的代码。每个函数在创建时也随配有一个prototype属性。它的值是一个拥有constructor属性且值为该函数的对象，这个和隐藏链接到Function.prototype完全不同。<br>函数字面量可以出现在任何允许表达式出现的地方。函数也可以被定义在其他函数中，一个内部函数除了可以访问自己的参数和变量，同时它也可以自由访问把它嵌套在其中的父函数的参数和变量。通过函数字面量创建的函数对象包含一个链接到外部上下文的链接。这被称为闭包。他是JavaScript强大表现力的来源。<br>JavaScript创建一个函数的时候，会给该对象设置一个‘调用’属性，当JavaScript调用一个函数时，可以理解为调用此函数的调用属性。</p>
<h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>//创建一个名为add的变量，并用来把两个数字相加的函数赋值给它。</p>
<pre><code>var add = function(a,b){
    return a + b
}</code></pre><p>函数字面量包括四个部分：第一个部分是保留字function第二个部分是函数名（可以被省略），函数可以通过函数名来递归的调用自己。第三部分是包围在圆括号中的一组参数。多个参数用逗号隔开。第四部分是包围在花括号中的一组语句。这些语句是函数的主体，在函数被调用的时候执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coffeeandtea.github.io/2021/01/10/https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王晓宇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋夜已凉 02">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/https/" itemprop="url">https? ssl/tls</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-10T12:46:03+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是安全？怎样才安全？"><a href="#什么是安全？怎样才安全？" class="headerlink" title="什么是安全？怎样才安全？"></a>什么是安全？怎样才安全？</h3><ul>
<li>机密性</li>
<li>完整性</li>
<li>身份认证</li>
<li>不可否认</li>
</ul>
<p>https除了协议名和端口号（443）这两点不同之外在语法、语义上和http完全一样。</p>
<p>https能够鉴别危险的网站，并且尽最大可能保证你的上网安全，防御黑客对信息的窃听、篡改或者“钓鱼”、伪造。</p>
<p>https的秘密在于它把层的传输协议由tcp/ip换成了ssl/tls，由Http over tcp/ip变成了http over ssl/tls,让http运行在了安全的ssl/tls协议上，收发报文不再使用Socket API,而是调用专门的安全接口。</p>
<h3 id="ssl-tls"><a href="#ssl-tls" class="headerlink" title="ssl/tls"></a>ssl/tls</h3><p>ssl—安全套接层，在osi模型中处于第五层，由网景公司于1994年发明，有v2和v3两个版本，而v1版本因为有严重的缺陷从未公开过。</p>
<p>ssl发展到v3时期已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组IETF在1999年把它改名为tls（传输层安全），正式标准化，版本号重新从1.0算起，所以其实TLS1.0就是SSLv3.1。</p>
<p>今天的tls已经发行了有三个版本，2006年的1.1、 2008年的1.2、和2018年的1.3,每个新版本都紧跟着密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域的权威标准。</p>
<p>目前应用最为广泛的tls是1.2，而之前的协议都已经被认为是不安全的，各大浏览器即将在2020年左右停止支持。</p>
<p>tls由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>
<p>浏览器和服务器在使用tls建立连接的时候需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为密码套件。</p>
<h5 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h5><p>是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它来作为底层库来实现tls功能，包括常用的web服务器Apache、Nginx等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王晓宇</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王晓宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
